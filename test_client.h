#pragma once

#include "arclen_helper.h"
#include "traj_loader.h"
#include "util.h"
#include "render/trajectory.h"


namespace otv {

/// Stores trajectory data that is known ahead of time in host memory, then gradually feeds it
/// to the renderer to simulate streaming.
/// NOTE: This type is only used for testing and not required to implement the OnTubeVis API.
struct test_client {
	/// Wrapper around a rendered trajectory that can be used to simulate streaming by gradually
	/// adding data from a buffer.
	struct trajectory {
		/// The range of nodes in the client's buffer belonging to this trajectory.
		ro_range<unsigned> node_idcs;
		/// The index of the next segment in the client's buffer belonging to this trajectory.
		/// There is always one fewer segment than nodes, so there is no need to store the maximum
		/// index.
		unsigned segment_idx;
		/// The ID under which this is managed by the render state.
		otv::trajectory::id_type id;
	};

	/// Host-side data for one glyph layer.
	struct glyph_layer {
		glyph_layer() = default;

		glyph_layer(const glyph_layer &) = delete;
		glyph_layer(glyph_layer &&) noexcept = default;

		glyph_layer &operator= (const glyph_layer &) = delete;
		glyph_layer &operator= (glyph_layer &&) noexcept = default;

		/// The ranges of glyphs located on each segment.
		std::vector<index_range<glyph_count_type>> ranges;
		/// The attributes defining each glyph.
		glyph_attributes attribs;
	};

	/// The render "server" used by the client.
	render_state &render;

	/// render data generated by the trajectory manager
	const traj_manager<float>::render_data *data;

	/// Glyph data.
	per_layer<glyph_layer> glyphs;

	/// segment-wise arclength approximations (set of 4 cubic bezier curves returning global
	/// trajectory arclength at the segment, packed into the columns of a 4x4 matrix)
	arclen::parametrization arclen_data;

	/// Data specific to each trajectory.
	std::vector<trajectory> trajectories;


	/// Append all data points up to the current timestamp to their respective trajectory.
	void update ();
};

} // namespace otv
