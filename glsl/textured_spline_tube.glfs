#version 460
#define M_PI 3.14159265359
#define M_INV_PI 0.31830988618

#define USE_CONSERVATIVE_DEPTH 0
#define USE_CUBIC_TANGENTS 1
#define USE_VIEW_SPACE_POSITION 1

#if USE_CONSERVATIVE_DEPTH == 1
#extension GL_ARB_conservative_depth : enable
#endif

/*
	0: NO_OP
	1: RASTERIZE_DEBUG
	2: RAYCAST_DEBUG
	3: RAYCAST
*/
#define MODE 3

#define ITERATION_COUNT 10
#define FLT_EPS 1.19209290e-07
#define POS_INF 3e+37
#define NEG_INF -3e+37
#define N0 3
#define N1 5





#define DEBUG_SEGMENTS 0

#define ENABLE_FRAMEWORK_LIGHTING 1
#define ENABLE_AMBIENT_OCCLUSION 1

#define GRID_MODE 0
#define ENABLE_FUZZY_GRID 0
#define GRID_NORMAL_SETTINGS 0
#define OUTLINE_INWARDS 0

#define CONSTANT_FLOAT_UNIFORM_COUNT 0
#define CONSTANT_COLOR_UNIFORM_COUNT 0
#define MAPPING_PARAMETER_UNIFORM_COUNT 0
#define L0_VISIBLE 1
#define L0_MAPPED_ATTRIB_COUNT 0
#define L0_GLYPH_DEFINITION
#define L1_VISIBLE 1
#define L1_MAPPED_ATTRIB_COUNT 0
#define L1_GLYPH_DEFINITION
#define L2_VISIBLE 1
#define L2_MAPPED_ATTRIB_COUNT 0
#define L2_GLYPH_DEFINITION
#define L3_VISIBLE 1
#define L3_MAPPED_ATTRIB_COUNT 0
#define L3_GLYPH_DEFINITION








//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

//***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
//***** end interface of surface.glsl ***********************************




#if ENABLE_AMBIENT_OCCLUSION == 1
layout (binding = 0) uniform sampler3D density_tex;
#endif
layout (binding = 1) uniform sampler2D color_maps_tex;





struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

struct Hit {
	float l;
	float t;
	vec3 normal;
	vec3 sp;
	bool cap;
};

uniform vec3 eye_pos;
uniform vec4 viewport;
uniform float cap_clip_distance;

#if USE_VIEW_SPACE_POSITION == 1
in vec3 position_fs;
#endif
in flat float l_offset_fs;
in flat uint color0_fs;
in flat uint color1_fs;
in flat QTube qTube_fs;
in flat int segment_id_fs;
#if USE_CUBIC_TANGENTS == 1
in flat mat4 SM_fs; // spline matrix
#endif








// ambient occlusion parameters
uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

// grid parameters
struct grid_parameters {
	vec2 scaling;
	float thickness;
	float blend_factor;
};
uniform vec4 grid_color;
uniform float normal_mapping_scale = 1.0;
uniform grid_parameters grids[2];

// attribute mapping parameters
#if CONSTANT_FLOAT_UNIFORM_COUNT > 0
uniform float glyph_cf_param[CONSTANT_FLOAT_UNIFORM_COUNT];
#endif
#if CONSTANT_COLOR_UNIFORM_COUNT > 0
uniform vec3 glyph_cc_param[CONSTANT_COLOR_UNIFORM_COUNT];
#endif

#if MAPPING_PARAMETER_UNIFORM_COUNT > 0
uniform vec4 glyph_m_param[MAPPING_PARAMETER_UNIFORM_COUNT];
#endif

uniform struct {
	bool use_curvature_correction;
	float length_scale;
	float antialias_radius;
} general_settings;
















#if USE_CONSERVATIVE_DEPTH == 1
layout (depth_greater) out float gl_FragDepth;
#endif

layout (location = 0) out vec4 frag_color;

// arclen approximations SBO
layout (std430, binding = 1) readonly buffer arclen_buffer { 
  mat4 b[]; // 4 cubic beziers packed into colums of mat4
};

float eval_cubic_bezier(float t, vec4 cp) {
	const mat4 Mc = mat4(
		1, -3,  3, -1,
		0,  3, -6,  3,
		0,  0,  3, -3,
		0,  0,  0,  1
	);
	return dot(vec4(1.0, t, t*t, t*t*t), Mc * cp);
}

// arclength evaluation
// length scale should be set to 1/radius with curvature correction on
float alen (float t)
{
	const float t4 = t+t+t+t;
	const int seg = max(int(min(t4, 3)), 0);
	const float t_inner = t4 - seg;
	return eval_cubic_bezier(t_inner, b[segment_id_fs][seg]);
}

float Pow2(float x) { return x * x; }
float Pow3(float x) { return x * x * x; }

vec2 SolveQuadratic(float a, float b, float c) {
    if(abs(a) < FLT_EPS) {
		if(abs(b) < FLT_EPS)
			return vec2(-2.0, 2.0);
		else
			return vec2(-c / b, 2.0);
    } else {
		float discr = b * b - 4.0 * a * c;
		if(abs(discr) < FLT_EPS) return vec2(-b / (2.0 * a), 2.0);
		if(discr < 0.0) return vec2(-2.0, 2.0);
		vec2 r = (-vec2(b) + vec2(-1.0, 1.0) * vec2(sqrt(discr))) / (2.0 * a);
		return r.x < r.y ? r.xy : r.yx;
    }
}

void Pow2(in float c[3], out float o_c[5]) {
	o_c[0] = c[0] * c[0]; 
	o_c[1] =  2.0 * c[0] * c[1];
	o_c[2] = c[1] * c[1] +  2.0 * c[0] * c[2];
	o_c[3] =  2.0 * c[2] * c[1];
	o_c[4] = c[2] * c[2];
}

void Sub(in float a[5], in float b[5], out float o_c[5]) {
	o_c[0] = a[0] - b[0];
	o_c[1] = a[1] - b[1];
	o_c[2] = a[2] - b[2];
	o_c[3] = a[3] - b[3];
	o_c[4] = a[4] - b[4];
}

float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5, float c6) { return x * (x * (x * (x * (x * (x * c6 + c5) + c4) + c3) + c2) + c1) + c0; }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5) { return EvalPoly(x, c0,c1,c2,c3,c4,c5,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4) { return EvalPoly(x, c0,c1,c2,c3,c4,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3) { return EvalPoly(x, c0,c1,c2,c3,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2) { return EvalPoly(x, c0,c1,c2,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1) { return EvalPoly(x, c0,c1,0.0,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0) { return EvalPoly(x, c0,0.0,0.0,0.0,0.0,0.0,0.0); }

//float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
//float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2] * 2.0); }
//float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2] * 2.0);       }
//float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]);             }
//float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2] * 2.0, c[3] * 3.0, c[4] * 4.0); }
//float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2] * 2.0, c[3] * 6.0, c[4] * 12.0);      }
//float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3] * 6.0, c[4] * 24.0);                  }

// same as above, but multiplication wit 2, 3, or 4 is replaced with addition (gives a small performance boost)
float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2] + c[2]); }
float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2] + c[2]); }
float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]); }
float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2] + c[2], c[3] + c[3] + c[3], c[4] + c[4] + c[4] + c[4]); }
float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2] + c[2], c[3] * 6.0, c[4] * 12.0); }
float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3] * 6.0, c[4] * 24.0); }

vec3 EvalCSpline(vec3 p1, vec3 t1, vec3 p2, vec3 t2, float l)
{
	vec3 h1 = p1 + t1 / 3.0;
	vec3 h2 = p2 - t2 / 3.0;
	
	vec3 a1 = mix(p1, h1, l);
	vec3 a2 = mix(h1, h2, l);
	vec3 a3 = mix(h2, p2, l);
	
	vec3 b1 = mix(a1, a2, l);
	vec3 b2 = mix(a2, a3, l);
	
	return mix(b1, b2, l);
}

#define DEF_FINDROOTS(N, D)                                                                         \
void FindRoots##D(float poly_C[N1], float x_i[N], int m_i[N], out float x_o[N+1], out int m_o[N+1]) \
{	                                                                                                \
    m_o[0] = m_o[N] = 1;                                                                            \
	x_o[0] = x_i[0];                                                                                \
	                                                                                                \
	uint j = 0;                                                                                     \
	                                                                                                \
	float x_l = x_i[0];                                                                             \
	float y_l = EvalPoly##D(x_l, poly_C);                                                           \
	float sy_l = sign(y_l);                                                                         \
                                                                                                    \
	for(uint i = 1; i < N; ++i) {                                                                   \
		float x_r = x_i[i];                                                                         \
		float y_r = EvalPoly##D(x_r, poly_C);                                                       \
		float sy_r = sign(y_r);                                                                     \
		                                                                                            \
		x_o[i] = 0.0;                                                                               \
		                                                                                            \
		if(m_i[i] == 1) {                                                                           \
			if(sy_l != sy_r) {                                                                      \
				float n = x_l;                                                                      \
				float p = x_r;                                                                      \
				float ny = EvalPoly##D(n, poly_C);                                                  \
				float py = EvalPoly##D(p, poly_C);                                                  \
				                                                                                    \
				if(ny > 0.0 && py < 0.0) {                                                          \
					float t = n;                                                                    \
					n = p; p = t;                                                                   \
				}                                                                                   \
				                                                                                    \
				for(uint j = 0; j < ITERATION_COUNT; ++j) {                                         \
					float m = (n + p) * 0.5;                                                        \
					float f = EvalPoly##D(m, poly_C);                                               \
					                                                                                \
					if(f < 0.0) n = m;                                                              \
					else p = m;                                                                     \
				}                                                                                   \
				                                                                                    \
				x_o[i] = (n + p) * 0.5;                                                             \
                                                                                                    \
				m_o[i] = 1;                                                                         \
			} else {			                                                                    \
				m_o[i] = 0;                                                                         \
			}                                                                                       \
			                                                                                        \
			x_l = x_r;                                                                              \
			y_l = y_r;                                                                              \
			sy_l = sy_r;                                                                            \
		} else {                                                                                    \
			m_o[i] = 0;                                                                             \
		}                                                                                           \
	}                                                                                               \
	                                                                                                \
	x_o[N] = x_i[N - 1];                                                                            \
}

DEF_FINDROOTS(4, D1)
DEF_FINDROOTS(5, D0)

//-----------------------------------------------------------//
// Produces an orthogonal vector to v. Doesn’t require the input
// to be normalized and doesn’t normalise the output. 
// source: http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
vec3 GetOrthoVec(vec3 v)
{
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0f) : vec3(0.0f, -v.z, v.y);
}

void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

vec3 qSplineEval(float l, float curveX[N0], float curveY[N0], float curveZ[N0])
{
	return vec3(
		EvalPolyD0(l, curveX), 
		EvalPolyD0(l, curveY), 
		EvalPolyD0(l, curveZ)
	);
}

float qSplineIDistEval(float t, float curveX[N0], float polyB_C[N1])
{		
	float term  = EvalPolyD0(t, curveX);
	float discr = EvalPolyD0(t, polyB_C);
		
	if(discr < 0.0) return POS_INF;
	else return term - sqrt(discr);
}

#define qSplineIDist_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineIDist_Paras curveX, polyB_C

float qSplineD1Eval(float t, float curveX[N0], float polyB_C[N1])
{	 		
	float f1D1 = EvalPolyD1(t, curveX);	
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);

	return f1D1 - f2D1 * 0.5 * inversesqrt(max(0.0, f2D0));
}

#define qSplineD1_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD1_Paras curveX, polyB_C

float qSplineD2Eval(float t, float curveX[N0], float polyB_C[N1])
{		
	float f1D1 = EvalPolyD1(t, curveX);
	float f1D2 = EvalPolyD2(t, curveX);
		
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	
	f2D0 = max(0.0, f2D0);
	
	return (Pow2(f2D1) / f2D0 * 0.25 - f2D2 * 0.5) * inversesqrt(f2D0) + f1D2;
}

#define qSplineD2_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD2_Paras curveX, polyB_C

float qSplineD3Eval(float t, float polyB_C[N1])
{
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	float f2D3 = EvalPolyD3(t, polyB_C);

	f2D0 = max(0.0, f2D0);

	return (-3.0 * Pow3(f2D1) + 6.0 * f2D0 * f2D1 * f2D2 - 4.0 * Pow2(f2D0) * f2D3) / Pow2(f2D0) * inversesqrt(f2D0);
}

#define qSplineD3_ParasDec float polyB_C[N1]
#define qSplineD3_Paras polyB_C

#define DEF_binRootFinder(func)                                    \
float func##_BinRootFinder_Eval(float n, float p, func##_ParasDec) \
{		                                                           \
	if(func##Eval(n, func##_Paras) > 0.0) return n;                \
	if(func##Eval(p, func##_Paras) < 0.0) return p;		           \
		                                                           \
	for(uint i = 0; i < ITERATION_COUNT; ++i) {                    \
		float m = (n + p) * 0.5;                                   \
		float f = func##Eval(m, func##_Paras);                     \
			                                                       \
		if(f < 0.0) n = m;                                         \
		else p = m;                                                \
	}                                                              \
		                                                           \
	return (n + p) * 0.5;                                          \
}

DEF_binRootFinder(qSplineIDist)
DEF_binRootFinder(qSplineD1)
DEF_binRootFinder(qSplineD2)
DEF_binRootFinder(qSplineD3)

#define binRootFinder_Eval(n, p, func) func##_BinRootFinder_Eval(n, p, func##_Paras)

Hit EvalSplineISect(vec3 dir, vec3 s, vec3 h, vec3 t, float rs, float rh, float rt)
{
	Hit hit;
	hit.l = 0.0;
	hit.t = POS_INF;
	hit.normal = vec3(0.0);
	
	mat3 RM;
	RM[0] = dir;
	RM[1] = normalize(GetOrthoVec(dir));
	RM[2] = cross(dir, RM[1]);
	
	s *= RM;
	t *= RM;
	h *= RM;

	float curveX[N0];
	float curveY[N0];
	float curveZ[N0];

	float rcurve[N0];
	
	SplinePointsToPolyCoeffs(s.x, h.x, t.x, curveX);
	SplinePointsToPolyCoeffs(s.y, h.y, t.y, curveY);
	SplinePointsToPolyCoeffs(s.z, h.z, t.z, curveZ);	
	
	SplinePointsToPolyCoeffs(rs, rh, rt, rcurve);
	
	float polyB_C[N1];
		
	Pow2(rcurve, polyB_C);

	{
		float c[N1];
		Pow2(curveY, c);
		
		Sub(polyB_C, c, polyB_C);
	}
	
	{
		float c[N1];
		Pow2(curveZ, c);
		
		Sub(polyB_C, c, polyB_C);
	}
	
	float l1 = 0.0;
	float l2 = 0.0;
	
	vec4 roots = vec4(-1.0);
	
	float x2[4];
	int m2[4];
	
	vec2 r = SolveQuadratic(polyB_C[4] * 12.0, polyB_C[3] * 6.0, polyB_C[2] * 2.0);
	
	x2[0] = 0.0;
	x2[1] = r.x;
	x2[2] = r.y;
	x2[3] = 1.0;

	m2[0] = 1;
	m2[1] = (x2[1] <= 0.0 || x2[1] >= 1.0) ? 0 : 1;
	m2[2] = (x2[2] <= 0.0 || x2[2] >= 1.0) ? 0 : 1;
	m2[3] = 1;

	float x3[5];
	int m3[5];
	FindRootsD1(polyB_C, x2, m2, x3, m3);

	float x4[6];
	int m4[6];
	
	{		
		FindRootsD0(polyB_C, x3, m3, x4, m4);

		int rootType = 0;
		int rn = 0;
		
		if(EvalPolyD0(0.0, polyB_C) >= 0.0) {
								  roots.x =  0; rn = 1; rootType = 15;
		}
		
		if(m4[1] == 1) {
			if(rn == 0) 		{ roots.x = x4[1]; rn = 1; rootType = 15;						}
			else				{ roots.y = x4[1]; rn = 2; rootType = 10; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[2] == 1) {
			if     (rn == 0) 	{ roots.x = x4[2]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[2]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else 				{ roots.z = x4[2]; rn = 3; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[3] == 1) {
			if     (rn == 0) 	{ roots.x = x4[3]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[3]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[3]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[3]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[4] == 1) {
			if     (rn == 0) 	{ roots.x = x4[4]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[4]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[4]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[4]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(EvalPolyD0(1.0, polyB_C) > 0.0) {
			if     (rn == 1)	{ roots.y =   1.0; rn = 1; rootType = rootType == 0 ? 30 : 10;	}
			else				{ roots.w =   1.0; rn = 2; rootType = 20; 						}	
		}
		
		if(rootType == 10 || rootType == 15) rootType = 30;

		//region finalize
		if(rootType > 0) {
			if(rootType == 30) {
				float rootD3 = binRootFinder_Eval(roots.x, roots.y, qSplineD3);
				
				vec2 rootsD2;
				rootsD2.x = binRootFinder_Eval(rootD3, roots.x, qSplineD2);
				rootsD2.y = binRootFinder_Eval(rootD3, roots.y, qSplineD2);
				
				l1 = binRootFinder_Eval(roots.x, rootsD2.x, qSplineD1);
				l2 = binRootFinder_Eval(rootsD2.y, roots.y, qSplineD1);
			} else {
				l1 = binRootFinder_Eval(roots.x, roots.y, qSplineD1);
				
				if(rootType == 20)
					l2 = binRootFinder_Eval(roots.z, roots.w, qSplineD1);
				else
					l2 = l1;
			}
			
			float t1 = qSplineIDistEval(l1, curveX, polyB_C);
			float t2 = qSplineIDistEval(l2, curveX, polyB_C);
			
			float r1 = EvalPolyD0(l1, rcurve);
			float r2 = EvalPolyD0(l2, rcurve);
			
			bool hit1 = t1 > 0.0 && r1 > 0.0;
			bool hit2 = t2 > 0.0 && r2 > 0.0;
			
			if(hit1) {
				if(t1 < t2 || !hit2) {
					hit.t = t1;
					hit.l = l1;
				} else {
					hit.t = t2;
					hit.l = l2;
				}
			} else {
				hit.t = t2;
				hit.l = l2;
			}

			hit.cap = false;
			if (hit.l == 0.0)
				hit.cap = true;
			if (hit.l == 1.0)
				hit.cap = true;

			// mitigate inter-segment artifacts
			/*if (hit.l < 0.00001)
			{
				hit.l = 0.000001;
				hit.t = qSplineIDistEval(hit.l, curveX, polyB_C);
			}
			else if (hit.l > 0.99999)
			{
				hit.l = 0.999999;
				hit.t = qSplineIDistEval(hit.l, curveX, polyB_C);
			}*/

			// get the position on the spline at l
			hit.sp = qSplineEval(hit.l, curveX, curveY, curveZ);
			// transform from ray space to eye space
			hit.sp = RM * hit.sp;
			// calculate the intersection point of the ray with the spline tube
			vec3 ip = hit.t * dir;
			hit.normal = normalize(ip - hit.sp);
		}
		//endregion
	}

	return hit;
}

vec3 eval_quadratic_bezier_tangent(float t)
{
	mat3 Bk; // control point matrix
	Bk[0] = qTube_fs.s.pos;
	Bk[1] = qTube_fs.h.pos;
	Bk[2] = qTube_fs.e.pos;
	
	mat3 Mb; // quadratic bezier matrix
	Mb[0] = vec3( 1,  0,  0);
	Mb[1] = vec3(-2,  2,  0);
	Mb[2] = vec3( 1, -2,  1);

	mat3 M = Bk * Mb;
	
	// quadratic bezier (1, t, t^2)
	// 1st derivative (0, 1, 2t)
	return M * vec3(0.0, 1, 2.0*t);
}

#if USE_CUBIC_TANGENTS == 1
vec3 eval_cubic_hermite_tangent(float t)
{
	vec4 tvec = vec4(3.0*t*t, 2.0*t, 1.0, 0.0);
	return (SM_fs * tvec).xyz;
}
#endif
























#if ENABLE_AMBIENT_OCCLUSION == 1
float compute_ambient_occlusion_factor(in vec3 pos_eye, in vec3 normal_eye) {
	vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
	vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

	// do voxel cone tracing to determine occlusion of ambient light
	float ao = 0.0;

	mat3 R;
	R[1] = normal;
	R[0] = cross(R[1], normalize(pos));
	R[2] = cross(R[0], R[1]);

	for(int i = 0; i < 3; ++i) {
		vec3 sd = R * ambient_occlusion.sample_directions[i];

		float sample_distance = ambient_occlusion.sample_offset + 0.001;
		vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
		float lod_texel_size = 0.0f;
			
		float illumination = 1.0;

		do {
			// get cone base radius at current distance and then the according mipmap sample level
			float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
			float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

			lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

			vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
			float density = textureLod(density_tex, sample_pos, sample_level).r;
			// apply the compositing function
			illumination *= 1.0 - density * illumination;

			// get the next sample distance and position
			sample_distance += cone_radius;
		} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

		ao += (1.0 - illumination);
	}

	return 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
}
#endif





float grid_texture_fuzzy(in vec2 p, in float n) {
	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

	vec2 i = sin(M_PI*t);
	return max(i.x, i.y);
}

float grid_texture_aa(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, na+w, p_frac) + smoothstep(nb-w, nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

float grid_texture(in vec2 p, in float n) {
#if ENABLE_FUZZY_GRID == 1
	return grid_texture_fuzzy(p, n);
#else
	return grid_texture_aa(p, n , 1);
#endif
}

vec3 grid_normal(in vec2 p, in float n) {

	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

#if (GRID_NORMAL_SETTINGS & 3) == 0
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	vec3 normal = normalize(vec3(-xy.x, xy.y, max(z.x, z.y)));
#elif (GRID_NORMAL_SETTINGS & 3) == 1
	vec2 i = sin(M_PI*t);
	vec2 xy = sin(2.0*M_PI*t);

	vec3 normal = vec3(0.0, 0.0, 0.0);
#if GRID_NORMAL_SETTINGS & 8
	vec3 n0 = vec3(-xy.x, 0.0, 0.0);
	vec3 n1 = vec3(0.0, xy.y, 0.0);

	float d = abs(i.x - i.y);
	float sum = i.x + i.y;

	if(i.x > i.y) normal = n0;
	else normal = n1;

	if(d < 0.2) {
		float a = 1.0 - d / 0.2;
		vec3 n2 = 0.5*(n0 + n1);
		normal = mix(normal, n2, a);
	}
	float v = normal.x*normal.x + normal.y*normal.y;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#else
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

	float v = normal.x + normal.y;
	v *= v;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#endif

#elif (GRID_NORMAL_SETTINGS & 3) == 2
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif

	vec3 normal;
	if(i.x > i.y) normal = vec3(-xy.x, 0.0, z.x);
	else normal = vec3(0.0, xy.y, z.y);

    normal = normalize(normal);
#elif (GRID_NORMAL_SETTINGS & 3) == 3
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	
	vec3 normal = vec3(0.0, 0.0, max(z.x, z.y));
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

    normal = normalize(normal);
#endif

#if GRID_NORMAL_SETTINGS & 4
	normal.xy = -normal.xy;
#endif

    return normal;
}

float compute_grid_factor(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return 0.0;

	float grid_factor = 0.0;
	grid_factor = grids[0].blend_factor * grid_texture(grids[0].scaling*uv, grids[0].thickness);
	grid_factor = max(grid_factor, grids[1].blend_factor * grid_texture(grids[1].scaling*uv, grids[1].thickness));
	return min(grid_factor, 1.0);
}

vec3 compute_grid_normal(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return vec3(0.0, 0.0, 1.0);
	
	vec3 normal = vec3(0.0, 0.0, 1.0);
	vec3 normal0 = mix(normal, grid_normal(grids[0].scaling*uv, grids[0].thickness), grids[0].blend_factor);
	vec3 normal1 = mix(normal, grid_normal(grids[1].scaling*uv, grids[1].thickness), grids[1].blend_factor);

	float grid_blend_factor = grid_texture(grids[0].scaling*uv, grids[0].thickness);
	return normalize(mix(normal0, normal1, 1.0 - grid_blend_factor));
}















vec3 apply_visual_mappings(in vec3 color) {
	return color;
}






























// use a custom finish fragment method since the framework built-in one imposes a performance loss
void finish_fragment(vec4 color) {
	frag_color = vec4(clamp(pow(color.rgb, vec3(2.2)), 0.0, 0.999999), color.a);
}

void main()
{
#if MODE == 0
	discard;
	return;
#elif MODE == 1
	finish_fragment(vec4(1.0, 0.0, 0.0, 1.0));
	return;
#else

#if USE_VIEW_SPACE_POSITION == 0
	// transform fragment coordinates from window coordinates to clip coordinates
    vec4 coord = gl_FragCoord 
        * vec4(2.0 / viewport.z, 2.0 / viewport.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from clip coordinates to eye coordinates
    coord = get_inverse_projection_matrix() * coord;
    coord /= coord.w;

    // calculate the viewing ray
    vec3 direction = normalize(coord.xyz);
#else
	vec3 direction = normalize(position_fs);
#endif

	Hit hit = EvalSplineISect(direction,
		qTube_fs.s.pos, qTube_fs.h.pos, qTube_fs.e.pos,
		qTube_fs.s.rad, qTube_fs.h.rad, qTube_fs.e.rad
	);

#if MODE == 3
	gl_FragDepth = 1.0;
#endif

	if(hit.t == POS_INF || (hit.cap && hit.t > cap_clip_distance)) {
#if MODE == 2
		finish_fragment(vec4(1.0, 0.0, 0.0, 1.0));
#else
		discard;
#endif
	} else {
		vec3 hit_pos_eye = direction * hit.t;
		float spline_t = hit.l * 0.5 + l_offset_fs;
		// with zero tangents the cubic hermite interpolation is reduced to a linear problem
		vec3 base_color = mix(unpackUnorm4x8(color0_fs).rgb, unpackUnorm4x8(color1_fs).rgb, spline_t);

		vec4 v_eye = vec4(hit_pos_eye, 1.0);
		vec4 depth = get_projection_matrix() * v_eye;
		gl_FragDepth = 0.5*(depth.z / depth.w) + 0.5;

#if USE_CUBIC_TANGENTS == 0
		// tangent is already given in eye space
		vec3 tangent = normalize(eval_quadratic_bezier_tangent(hit.l));
#else
		// tangent is given in object space
		vec3 tangent = eval_cubic_hermite_tangent(spline_t);
		// transform the tangent from object space to eye space
		tangent = normalize(get_normal_matrix() * tangent);
#endif
		// calculate a bitangent which is orthogonal to the plane defined by the tangent and the vector from the eye position to the hit position
		vec3 b = normalize(cross(tangent, hit.sp));
		// the texture coordinate around the tubes perimeter is the acos of the dot product between the normal and the bitangent
		// normalized to [0,1]
		// since we are only interested in the eye-facing side of the tube, acos is sufficient here
		float v = acos(dot(b, hit.normal)) * M_INV_PI;

		vec2 uv = vec2(alen(spline_t), v);

		// The texture coordinate v (around the tube) lies in [0,1] at the front side (camera facing side) of the tube,
		// with 0 at the top and 1 at the bottom of the visible part of the tube (if the bitangent is pointing up in screen space).
		// The back side of the tube is parameterized in the same way, but we are only interested in the front side anyway.
		
		// Move the origin (0,0) to the center of the front side and scale the v coordinate to [-1,1]
		uv.t = 2.0 * uv.t - 1.0;

		// Correct the perspective distortion caused by the curved tube surface by rescaling the v coordinate around the tube.
		if(general_settings.use_curvature_correction)
			uv.t = sin(0.5*M_PI*uv.t);

		// apply the visual mappings to the tube base color
		vec4 final_color = vec4(apply_visual_mappings(base_color), 1.0);

		// highlight segments in debug mode if requested
#if DEBUG_SEGMENTS > 0
		if((segment_id&1) > 0) color *= 0.5;
#endif

		// apply grid
#if GRID_MODE & 1
		final_color.rgb = mix(color.rgb, grid_color.rgb, compute_grid_factor(uv) * grid_color.a);
#endif

#if ENABLE_FRAMEWORK_LIGHTING == 1
		// using the framework built-in lighting system costs about 2 ms for the fisch-wehr data set (impact reduces for larger data sets, possibly due to less overdraw)
		final_color = compute_reflected_appearance(hit_pos_eye, hit.normal, final_color, 1);
#else
		// basic diffuse lighting with light position at eye
		float diffuse = max(dot(-normalize(hit_pos_eye), hit.normal), 0.0);
		final_color.rgb *= 0.25 + 0.75*diffuse; // 25% ambient light
#endif

#if GRID_MODE & 2
		//vec3 gn = compute_grid_normal(uv);
		//vec3 bitangent_eye = cross(normal_eye, tangent_eye);
		//mat3 TBN = mat3(tangent_eye, bitangent_eye, normal_eye);
		//vec3 normal_eye_bump = mix(normal_eye, normalize(TBN * gn), normal_mapping_scale);
		//vec4 frag_color_bump = compute_reflected_appearance(pos_eye, normal_eye_bump, vec4(color, 1.0), 1);
		//float aa_factor = min(aa_texture(grids[0].scaling*uv, grids[0].thickness, 0.5) + aa_texture(grids[1].scaling*uv, grids[1].thickness, 0.5), 1);
		//frag_color = mix(frag_color, frag_color_bump, aa_factor);
#endif

		//apply ambient occlusion
		// change if to a define for maximum performance when ambient occlusion is disabled
#if ENABLE_AMBIENT_OCCLUSION == 1
		final_color.rgb *= compute_ambient_occlusion_factor(hit_pos_eye, hit.normal);
#endif


		/*	!!!
		*	enabling either compute_reflected_appearance or compute_ambient_occlusion_factor seems to disable the conservative depth test
		*	!!!
		*/

		
		finish_fragment(final_color);
	}
#endif
}
