#version 460
#define M_PI 3.14159265359
#define M_INV_PI 0.31830988618

#define USE_CONSERVATIVE_DEPTH 0
#define USE_CUBIC_TANGENTS 1
#define USE_VIEW_SPACE_POSITION 1

#if USE_CONSERVATIVE_DEPTH == 1
#extension GL_ARB_conservative_depth : enable
#endif

/*
	0: NO_OP
	1: RASTERIZE_DEBUG
	2: RAYCAST_DEBUG
	3: RAYCAST
*/
#define MODE 3

#define ITERATION_COUNT 10
#define FLT_EPS 1.19209290e-07
#define POS_INF 3e+37
#define NEG_INF -3e+37
#define N0 3
#define N1 5





#define DEBUG_SEGMENTS 0

#define ENABLE_FRAMEWORK_LIGHTING 1
#define ENABLE_AMBIENT_OCCLUSION 1

#define GRID_MODE 0
#define ENABLE_FUZZY_GRID 0
#define GRID_NORMAL_SETTINGS 0
#define OUTLINE_INWARDS 0

#define CONSTANT_FLOAT_UNIFORM_COUNT 0
#define CONSTANT_COLOR_UNIFORM_COUNT 0
#define MAPPING_PARAMETER_UNIFORM_COUNT 0
#define L0_VISIBLE 1
#define L0_MAPPED_ATTRIB_COUNT 0
#define L0_GLYPH_DEFINITION
#define L1_VISIBLE 1
#define L1_MAPPED_ATTRIB_COUNT 0
#define L1_GLYPH_DEFINITION
#define L2_VISIBLE 1
#define L2_MAPPED_ATTRIB_COUNT 0
#define L2_GLYPH_DEFINITION
#define L3_VISIBLE 1
#define L3_MAPPED_ATTRIB_COUNT 0
#define L3_GLYPH_DEFINITION








//***** begin interface of view.glsl ***********************************
mat4 get_modelview_matrix();
mat4 get_projection_matrix();
mat4 get_inverse_projection_matrix();
mat4 get_modelview_projection_matrix();
mat4 get_inverse_modelview_matrix();
mat4 get_inverse_modelview_projection_matrix();
mat3 get_normal_matrix();
mat3 get_inverse_normal_matrix();
//***** end interface of view.glsl ***********************************

//***** begin interface of surface.glsl ***********************************
vec4 compute_reflected_appearance(vec3 position_eye, vec3 normal_eye, vec4 color, int side);
//***** end interface of surface.glsl ***********************************




#if ENABLE_AMBIENT_OCCLUSION == 1
layout (binding = 0) uniform sampler3D density_tex;
#endif
layout (binding = 1) uniform sampler2D color_maps_tex;





struct QTubeNode {
	vec3 pos;
	float rad;
};

struct QTube {
	QTubeNode s;
	QTubeNode h;
	QTubeNode e;
};

struct Hit {
	float l;
	float t;
	vec3 normal;
	vec3 sp;
	bool cap;
};

uniform vec3 eye_pos;
uniform vec4 viewport;
uniform float cap_clip_distance;

#if USE_VIEW_SPACE_POSITION == 1
in vec3 position_fs;
#endif
in flat float l_offset_fs;
in flat uint color0_fs;
in flat uint color1_fs;
in flat QTube qTube_fs;
in flat int segment_id_fs;
#if USE_CUBIC_TANGENTS == 1
in flat mat4 SM_fs; // spline matrix
#endif








// ambient occlusion parameters
uniform struct {
	bool enable;
	float sample_offset;
	float sample_distance;
	float strength_scale;
	vec3 tex_offset;
	vec3 tex_scaling;
	vec3 texcoord_scaling;
	float texel_size;
	float cone_angle_factor;
	vec3 sample_directions[3];
} ambient_occlusion;

// grid parameters
struct grid_parameters {
	vec2 scaling;
	float thickness;
	float blend_factor;
};
uniform vec4 grid_color;
uniform float normal_mapping_scale = 1.0;
uniform grid_parameters grids[2];

// attribute mapping parameters
#if CONSTANT_FLOAT_UNIFORM_COUNT > 0
uniform float glyph_cf_param[CONSTANT_FLOAT_UNIFORM_COUNT];
#endif
#if CONSTANT_COLOR_UNIFORM_COUNT > 0
uniform vec3 glyph_cc_param[CONSTANT_COLOR_UNIFORM_COUNT];
#endif

#if MAPPING_PARAMETER_UNIFORM_COUNT > 0
uniform vec4 glyph_m_param[MAPPING_PARAMETER_UNIFORM_COUNT];
#endif

uniform struct {
	bool use_curvature_correction;
	float length_scale;
	float antialias_radius;
} general_settings;
















#if USE_CONSERVATIVE_DEPTH == 1
layout (depth_greater) out float gl_FragDepth;
#endif

layout (location = 0) out vec4 frag_color;






// arclen approximations SBO
layout (std430, binding = 1) readonly buffer arclen_buffer { 
  mat4 b[]; // 4 cubic beziers packed into colums of mat4
};




struct irange {
	int i0, n;
};

// attribute and range buffers for each glyph layer
// free attributes ssbos
// free attributes per-segment index ranges
#define DEF_GLYPH_DESC_AND_BUFFERS(I, N, B0, B1) \
struct glyph_desc##I { \
	float s; \
	uint debug_info; \
	float v[N]; \
}; \
layout (std430, binding=B0) readonly buffer attribs_buffer##I { \
	glyph_desc##I glyphs##I[]; \
}; \
layout (std430, binding=B1) readonly buffer ranges_buffer##I { \
	irange ranges##I[]; \
}; \

struct closest_glyphs_info {
	int prev, next, id;
	float dp, dn, d;
};

#define DEF_CLOSEST_SAMPLES(I, ranges, glyphs) \
bool get_closest_samples##I(in int segid, in float s, out closest_glyphs_info closest) { \
	const irange segment = ranges[segid]; \
	if (segment.n > 0) { \
		irange rng = segment; \
		while (rng.n > 1) { \
			const int mid_n = rng.n/2, mid = rng.i0+mid_n; \
			if (glyphs[mid].s > s) rng.n = mid_n; \
			else { rng.i0 = rng.i0 + mid_n; rng.n  = rng.n  - mid_n; } \
		} \
		closest.prev = rng.i0; \
		closest.next = rng.i0 < segment.i0+segment.n-1 ? rng.i0+1 : rng.i0; \
		closest.dp = s-glyphs[rng.i0].s; \
		closest.dn = glyphs[closest.next].s-s; \
		const bool n_lt_p = closest.dn < closest.dp; \
		closest.id = n_lt_p ? closest.next : closest.prev; \
		closest.d  = n_lt_p ? closest.dn : closest.dp; \
		return true; \
	} \
	return false; \
}

#if L0_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(0, L0_MAPPED_ATTRIB_COUNT, 2, 3)
DEF_CLOSEST_SAMPLES(0, ranges0, glyphs0)
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(1, L1_MAPPED_ATTRIB_COUNT, 4, 5)
DEF_CLOSEST_SAMPLES(1, ranges1, glyphs1)
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(2, L2_MAPPED_ATTRIB_COUNT, 6, 7)
DEF_CLOSEST_SAMPLES(2, ranges2, glyphs2)
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0
DEF_GLYPH_DESC_AND_BUFFERS(3, L3_MAPPED_ATTRIB_COUNT, 8, 9)
DEF_CLOSEST_SAMPLES(3, ranges3, glyphs3)
#endif










float eval_cubic_bezier(float t, vec4 cp) {
	const mat4 Mc = mat4(
		1, -3,  3, -1,
		0,  3, -6,  3,
		0,  0,  3, -3,
		0,  0,  0,  1
	);
	return dot(vec4(1.0, t, t*t, t*t*t), Mc * cp);
}

// arclength evaluation
// length scale should be set to 1/radius with curvature correction on
float alen (float t)
{
	const float t4 = t+t+t+t;
	const int seg = max(int(min(t4, 3)), 0);
	const float t_inner = t4 - seg;
	return eval_cubic_bezier(t_inner, b[segment_id_fs][seg]);
}

float Pow2(float x) { return x * x; }
float Pow3(float x) { return x * x * x; }

vec2 SolveQuadratic(float a, float b, float c) {
    if(abs(a) < FLT_EPS) {
		if(abs(b) < FLT_EPS)
			return vec2(-2.0, 2.0);
		else
			return vec2(-c / b, 2.0);
    } else {
		float discr = b * b - 4.0 * a * c;
		if(abs(discr) < FLT_EPS) return vec2(-b / (2.0 * a), 2.0);
		if(discr < 0.0) return vec2(-2.0, 2.0);
		vec2 r = (-vec2(b) + vec2(-1.0, 1.0) * vec2(sqrt(discr))) / (2.0 * a);
		return r.x < r.y ? r.xy : r.yx;
    }
}

void Pow2(in float c[3], out float o_c[5]) {
	o_c[0] = c[0] * c[0]; 
	o_c[1] =  2.0 * c[0] * c[1];
	o_c[2] = c[1] * c[1] +  2.0 * c[0] * c[2];
	o_c[3] =  2.0 * c[2] * c[1];
	o_c[4] = c[2] * c[2];
}

void Sub(in float a[5], in float b[5], out float o_c[5]) {
	o_c[0] = a[0] - b[0];
	o_c[1] = a[1] - b[1];
	o_c[2] = a[2] - b[2];
	o_c[3] = a[3] - b[3];
	o_c[4] = a[4] - b[4];
}

float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5, float c6) { return x * (x * (x * (x * (x * (x * c6 + c5) + c4) + c3) + c2) + c1) + c0; }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4, float c5) { return EvalPoly(x, c0,c1,c2,c3,c4,c5,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3, float c4) { return EvalPoly(x, c0,c1,c2,c3,c4,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2, float c3) { return EvalPoly(x, c0,c1,c2,c3,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1, float c2) { return EvalPoly(x, c0,c1,c2,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0, float c1) { return EvalPoly(x, c0,c1,0.0,0.0,0.0,0.0,0.0); }
float EvalPoly(float x, float c0) { return EvalPoly(x, c0,0.0,0.0,0.0,0.0,0.0,0.0); }

//float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
//float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2] * 2.0); }
//float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2] * 2.0);       }
//float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]);             }
//float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2] * 2.0, c[3] * 3.0, c[4] * 4.0); }
//float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2] * 2.0, c[3] * 6.0, c[4] * 12.0);      }
//float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3] * 6.0, c[4] * 24.0);                  }

// same as above, but multiplication wit 2, 3, or 4 is replaced with addition (gives a small performance boost)
float EvalPolyD0(float x, float c[3]) { return EvalPoly(x, c[0], c[1], c[2]); }
float EvalPolyD1(float x, float c[3]) { return EvalPoly(x, c[1], c[2] + c[2]); }
float EvalPolyD2(float x, float c[3]) { return EvalPoly(x, c[2] + c[2]); }
float EvalPolyD0(float x, float c[5]) { return EvalPoly(x, c[0], c[1], c[2], c[3], c[4]); }
float EvalPolyD1(float x, float c[5]) { return EvalPoly(x, c[1], c[2] + c[2], c[3] + c[3] + c[3], c[4] + c[4] + c[4] + c[4]); }
float EvalPolyD2(float x, float c[5]) { return EvalPoly(x, c[2] + c[2], c[3] * 6.0, c[4] * 12.0); }
float EvalPolyD3(float x, float c[5]) { return EvalPoly(x, c[3] * 6.0, c[4] * 24.0); }

vec3 EvalCSpline(vec3 p1, vec3 t1, vec3 p2, vec3 t2, float l)
{
	vec3 h1 = p1 + t1 / 3.0;
	vec3 h2 = p2 - t2 / 3.0;
	
	vec3 a1 = mix(p1, h1, l);
	vec3 a2 = mix(h1, h2, l);
	vec3 a3 = mix(h2, p2, l);
	
	vec3 b1 = mix(a1, a2, l);
	vec3 b2 = mix(a2, a3, l);
	
	return mix(b1, b2, l);
}

#define DEF_FINDROOTS(N, D)                                                                         \
void FindRoots##D(float poly_C[N1], float x_i[N], int m_i[N], out float x_o[N+1], out int m_o[N+1]) \
{	                                                                                                \
    m_o[0] = m_o[N] = 1;                                                                            \
	x_o[0] = x_i[0];                                                                                \
	                                                                                                \
	uint j = 0;                                                                                     \
	                                                                                                \
	float x_l = x_i[0];                                                                             \
	float y_l = EvalPoly##D(x_l, poly_C);                                                           \
	float sy_l = sign(y_l);                                                                         \
                                                                                                    \
	for(uint i = 1; i < N; ++i) {                                                                   \
		float x_r = x_i[i];                                                                         \
		float y_r = EvalPoly##D(x_r, poly_C);                                                       \
		float sy_r = sign(y_r);                                                                     \
		                                                                                            \
		x_o[i] = 0.0;                                                                               \
		                                                                                            \
		if(m_i[i] == 1) {                                                                           \
			if(sy_l != sy_r) {                                                                      \
				float n = x_l;                                                                      \
				float p = x_r;                                                                      \
				float ny = EvalPoly##D(n, poly_C);                                                  \
				float py = EvalPoly##D(p, poly_C);                                                  \
				                                                                                    \
				if(ny > 0.0 && py < 0.0) {                                                          \
					float t = n;                                                                    \
					n = p; p = t;                                                                   \
				}                                                                                   \
				                                                                                    \
				for(uint j = 0; j < ITERATION_COUNT; ++j) {                                         \
					float m = (n + p) * 0.5;                                                        \
					float f = EvalPoly##D(m, poly_C);                                               \
					                                                                                \
					if(f < 0.0) n = m;                                                              \
					else p = m;                                                                     \
				}                                                                                   \
				                                                                                    \
				x_o[i] = (n + p) * 0.5;                                                             \
                                                                                                    \
				m_o[i] = 1;                                                                         \
			} else {			                                                                    \
				m_o[i] = 0;                                                                         \
			}                                                                                       \
			                                                                                        \
			x_l = x_r;                                                                              \
			y_l = y_r;                                                                              \
			sy_l = sy_r;                                                                            \
		} else {                                                                                    \
			m_o[i] = 0;                                                                             \
		}                                                                                           \
	}                                                                                               \
	                                                                                                \
	x_o[N] = x_i[N - 1];                                                                            \
}

DEF_FINDROOTS(4, D1)
DEF_FINDROOTS(5, D0)

//-----------------------------------------------------------//
// Produces an orthogonal vector to v. Doesn’t require the input
// to be normalized and doesn’t normalise the output. 
// source: http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts
vec3 GetOrthoVec(vec3 v)
{
    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0f) : vec3(0.0f, -v.z, v.y);
}

void SplinePointsToPolyCoeffs(float p0, float h, float p1, out float o_c[3])
{
	o_c[0] = p0;
	o_c[1] = -2.0 * p0 + 2.0 * h;
	o_c[2] =   p0 + p1 - 2.0 * h;
}

vec3 qSplineEval(float l, float curveX[N0], float curveY[N0], float curveZ[N0])
{
	return vec3(
		EvalPolyD0(l, curveX), 
		EvalPolyD0(l, curveY), 
		EvalPolyD0(l, curveZ)
	);
}

float qSplineIDistEval(float t, float curveX[N0], float polyB_C[N1])
{		
	float term  = EvalPolyD0(t, curveX);
	float discr = EvalPolyD0(t, polyB_C);
		
	if(discr < 0.0) return POS_INF;
	else return term - sqrt(discr);
}

#define qSplineIDist_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineIDist_Paras curveX, polyB_C

float qSplineD1Eval(float t, float curveX[N0], float polyB_C[N1])
{	 		
	float f1D1 = EvalPolyD1(t, curveX);	
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);

	return f1D1 - f2D1 * 0.5 * inversesqrt(max(0.0, f2D0));
}

#define qSplineD1_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD1_Paras curveX, polyB_C

float qSplineD2Eval(float t, float curveX[N0], float polyB_C[N1])
{		
	float f1D1 = EvalPolyD1(t, curveX);
	float f1D2 = EvalPolyD2(t, curveX);
		
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	
	f2D0 = max(0.0, f2D0);
	
	return (Pow2(f2D1) / f2D0 * 0.25 - f2D2 * 0.5) * inversesqrt(f2D0) + f1D2;
}

#define qSplineD2_ParasDec float curveX[N0], float polyB_C[N1]
#define qSplineD2_Paras curveX, polyB_C

float qSplineD3Eval(float t, float polyB_C[N1])
{
	float f2D0 = EvalPolyD0(t, polyB_C);
	float f2D1 = EvalPolyD1(t, polyB_C);
	float f2D2 = EvalPolyD2(t, polyB_C);
	float f2D3 = EvalPolyD3(t, polyB_C);

	f2D0 = max(0.0, f2D0);

	return (-3.0 * Pow3(f2D1) + 6.0 * f2D0 * f2D1 * f2D2 - 4.0 * Pow2(f2D0) * f2D3) / Pow2(f2D0) * inversesqrt(f2D0);
}

#define qSplineD3_ParasDec float polyB_C[N1]
#define qSplineD3_Paras polyB_C

#define DEF_binRootFinder(func)                                    \
float func##_BinRootFinder_Eval(float n, float p, func##_ParasDec) \
{		                                                           \
	if(func##Eval(n, func##_Paras) > 0.0) return n;                \
	if(func##Eval(p, func##_Paras) < 0.0) return p;		           \
		                                                           \
	for(uint i = 0; i < ITERATION_COUNT; ++i) {                    \
		float m = (n + p) * 0.5;                                   \
		float f = func##Eval(m, func##_Paras);                     \
			                                                       \
		if(f < 0.0) n = m;                                         \
		else p = m;                                                \
	}                                                              \
		                                                           \
	return (n + p) * 0.5;                                          \
}

DEF_binRootFinder(qSplineIDist)
DEF_binRootFinder(qSplineD1)
DEF_binRootFinder(qSplineD2)
DEF_binRootFinder(qSplineD3)

#define binRootFinder_Eval(n, p, func) func##_BinRootFinder_Eval(n, p, func##_Paras)

Hit EvalSplineISect(vec3 dir, vec3 s, vec3 h, vec3 t, float rs, float rh, float rt)
{
	Hit hit;
	hit.l = 0.0;
	hit.t = POS_INF;
	hit.normal = vec3(0.0);
	
	mat3 RM;
	RM[0] = dir;
	RM[1] = normalize(GetOrthoVec(dir));
	RM[2] = cross(dir, RM[1]);
	
	s *= RM;
	t *= RM;
	h *= RM;

	float curveX[N0];
	float curveY[N0];
	float curveZ[N0];

	float rcurve[N0];
	
	SplinePointsToPolyCoeffs(s.x, h.x, t.x, curveX);
	SplinePointsToPolyCoeffs(s.y, h.y, t.y, curveY);
	SplinePointsToPolyCoeffs(s.z, h.z, t.z, curveZ);	
	
	SplinePointsToPolyCoeffs(rs, rh, rt, rcurve);
	
	float polyB_C[N1];
		
	Pow2(rcurve, polyB_C);

	{
		float c[N1];
		Pow2(curveY, c);
		
		Sub(polyB_C, c, polyB_C);
	}
	
	{
		float c[N1];
		Pow2(curveZ, c);
		
		Sub(polyB_C, c, polyB_C);
	}
	
	float l1 = 0.0;
	float l2 = 0.0;
	
	vec4 roots = vec4(-1.0);
	
	float x2[4];
	int m2[4];
	
	vec2 r = SolveQuadratic(polyB_C[4] * 12.0, polyB_C[3] * 6.0, polyB_C[2] * 2.0);
	
	x2[0] = 0.0;
	x2[1] = r.x;
	x2[2] = r.y;
	x2[3] = 1.0;

	m2[0] = 1;
	m2[1] = (x2[1] <= 0.0 || x2[1] >= 1.0) ? 0 : 1;
	m2[2] = (x2[2] <= 0.0 || x2[2] >= 1.0) ? 0 : 1;
	m2[3] = 1;

	float x3[5];
	int m3[5];
	FindRootsD1(polyB_C, x2, m2, x3, m3);

	float x4[6];
	int m4[6];
	
	{		
		FindRootsD0(polyB_C, x3, m3, x4, m4);

		int rootType = 0;
		int rn = 0;
		
		if(EvalPolyD0(0.0, polyB_C) >= 0.0) {
								  roots.x =  0; rn = 1; rootType = 15;
		}
		
		if(m4[1] == 1) {
			if(rn == 0) 		{ roots.x = x4[1]; rn = 1; rootType = 15;						}
			else				{ roots.y = x4[1]; rn = 2; rootType = 10; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[2] == 1) {
			if     (rn == 0) 	{ roots.x = x4[2]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[2]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else 				{ roots.z = x4[2]; rn = 3; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[3] == 1) {
			if     (rn == 0) 	{ roots.x = x4[3]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[3]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[3]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[3]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(m4[4] == 1) {
			if     (rn == 0) 	{ roots.x = x4[4]; rn = 1; rootType = 15;						}
			else if(rn == 1)	{ roots.y = x4[4]; rn = 2; rootType = rootType == 0 ? 30 : 10;	}	
			else if(rn == 2)	{ roots.z = x4[4]; rn = 3; rootType = 20; 						}	
			else 				{ roots.w = x4[4]; rn = 4; rootType = 20; 						}	
		} else if(rootType == 15) {
			rootType = 0;
		}
		
		if(EvalPolyD0(1.0, polyB_C) > 0.0) {
			if     (rn == 1)	{ roots.y =   1.0; rn = 1; rootType = rootType == 0 ? 30 : 10;	}
			else				{ roots.w =   1.0; rn = 2; rootType = 20; 						}	
		}
		
		if(rootType == 10 || rootType == 15) rootType = 30;

		//region finalize
		if(rootType > 0) {
			if(rootType == 30) {
				float rootD3 = binRootFinder_Eval(roots.x, roots.y, qSplineD3);
				
				vec2 rootsD2;
				rootsD2.x = binRootFinder_Eval(rootD3, roots.x, qSplineD2);
				rootsD2.y = binRootFinder_Eval(rootD3, roots.y, qSplineD2);
				
				l1 = binRootFinder_Eval(roots.x, rootsD2.x, qSplineD1);
				l2 = binRootFinder_Eval(rootsD2.y, roots.y, qSplineD1);
			} else {
				l1 = binRootFinder_Eval(roots.x, roots.y, qSplineD1);
				
				if(rootType == 20)
					l2 = binRootFinder_Eval(roots.z, roots.w, qSplineD1);
				else
					l2 = l1;
			}
			
			float t1 = qSplineIDistEval(l1, curveX, polyB_C);
			float t2 = qSplineIDistEval(l2, curveX, polyB_C);
			
			float r1 = EvalPolyD0(l1, rcurve);
			float r2 = EvalPolyD0(l2, rcurve);
			
			bool hit1 = t1 > 0.0 && r1 > 0.0;
			bool hit2 = t2 > 0.0 && r2 > 0.0;
			
			if(hit1) {
				if(t1 < t2 || !hit2) {
					hit.t = t1;
					hit.l = l1;
				} else {
					hit.t = t2;
					hit.l = l2;
				}
			} else {
				hit.t = t2;
				hit.l = l2;
			}

			hit.cap = false;
			if (hit.l == 0.0)
				hit.cap = true;
			if (hit.l == 1.0)
				hit.cap = true;

			// mitigate inter-segment artifacts
			/*if (hit.l < 0.00001)
			{
				hit.l = 0.000001;
				hit.t = qSplineIDistEval(hit.l, curveX, polyB_C);
			}
			else if (hit.l > 0.99999)
			{
				hit.l = 0.999999;
				hit.t = qSplineIDistEval(hit.l, curveX, polyB_C);
			}*/

			// get the position on the spline at l
			hit.sp = qSplineEval(hit.l, curveX, curveY, curveZ);
			// transform from ray space to eye space
			hit.sp = RM * hit.sp;
			// calculate the intersection point of the ray with the spline tube
			vec3 ip = hit.t * dir;
			hit.normal = normalize(ip - hit.sp);
		}
		//endregion
	}

	return hit;
}

vec3 eval_quadratic_bezier_tangent(float t)
{
	mat3 Bk; // control point matrix
	Bk[0] = qTube_fs.s.pos;
	Bk[1] = qTube_fs.h.pos;
	Bk[2] = qTube_fs.e.pos;
	
	mat3 Mb; // quadratic bezier matrix
	Mb[0] = vec3( 1,  0,  0);
	Mb[1] = vec3(-2,  2,  0);
	Mb[2] = vec3( 1, -2,  1);

	mat3 M = Bk * Mb;
	
	// quadratic bezier (1, t, t^2)
	// 1st derivative (0, 1, 2t)
	return M * vec3(0.0, 1, 2.0*t);
}

#if USE_CUBIC_TANGENTS == 1
vec3 eval_cubic_hermite_tangent(float t)
{
	vec4 tvec = vec4(3.0*t*t, 2.0*t, 1.0, 0.0);
	return (SM_fs * tvec).xyz;
}
#endif
























#if ENABLE_AMBIENT_OCCLUSION == 1
float compute_ambient_occlusion_factor(in vec3 pos_eye, in vec3 normal_eye) {
	vec3 pos = (get_inverse_modelview_matrix() * vec4(pos_eye, 1.0)).xyz;
	vec3 normal = normalize(get_inverse_normal_matrix() * normal_eye);

	// do voxel cone tracing to determine occlusion of ambient light
	float ao = 0.0;

	mat3 R;
	R[1] = normal;
	R[0] = cross(R[1], normalize(pos));
	R[2] = cross(R[0], R[1]);

	for(int i = 0; i < 3; ++i) {
		vec3 sd = R * ambient_occlusion.sample_directions[i];

		float sample_distance = ambient_occlusion.sample_offset + 0.001;
		vec3 normalized_pos = (pos - ambient_occlusion.tex_offset) * ambient_occlusion.tex_scaling;
		float lod_texel_size = 0.0f;
			
		float illumination = 1.0;

		do {
			// get cone base radius at current distance and then the according mipmap sample level
			float cone_radius = sample_distance * ambient_occlusion.cone_angle_factor;
			float sample_level = clamp(log2(cone_radius / ambient_occlusion.texel_size), 0.0, 7.0);

			lod_texel_size = pow(2.0, sample_level) * ambient_occlusion.texel_size;

			vec3 sample_pos = normalized_pos + sample_distance * sd * ambient_occlusion.texcoord_scaling;
			float density = textureLod(density_tex, sample_pos, sample_level).r;
			// apply the compositing function
			illumination *= 1.0 - density * illumination;

			// get the next sample distance and position
			sample_distance += cone_radius;
		} while(sample_distance < ambient_occlusion.sample_distance - lod_texel_size && illumination > 0.02);

		ao += (1.0 - illumination);
	}

	return 1.0 - clamp(ambient_occlusion.strength_scale * ao / 3.0, 0.0, 1.0);
}
#endif





float grid_texture_fuzzy(in vec2 p, in float n) {
	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

	vec2 i = sin(M_PI*t);
	return max(i.x, i.y);
}

float grid_texture_aa(in vec2 p, in float n, float aa_strength) {
	// pre-filter AA preparations
	const float na = n*0.5, nb = 1.0-n*0.5;
	const vec2 p_frac = fract(p), w = aa_strength*fwidth(p);

	// coordinates
	const vec2 i = vec2(1) - smoothstep(na-w, na+w, p_frac) + smoothstep(nb-w, nb+w, p_frac);

	//pattern (from https://www.shadertoy.com/view/XtBfzz)
	return 1.0 - (1.0-i.s)*(1.0-i.t);	// grid
	//return 1.0-i.s*i.t;				// squares
	//return 1.0-i.s-i.t+2.0*i.s*i.t;	// checker
}

float grid_texture(in vec2 p, in float n) {
#if ENABLE_FUZZY_GRID == 1
	return grid_texture_fuzzy(p, n);
#else
	return grid_texture_aa(p, n , 1);
#endif
}

vec3 grid_normal(in vec2 p, in float n) {

	// coordinates
	vec2 s = fract(p + 0.5*n);
	vec2 t = clamp(s / n, 0.0, 1.0);

#if (GRID_NORMAL_SETTINGS & 3) == 0
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	vec3 normal = normalize(vec3(-xy.x, xy.y, max(z.x, z.y)));
#elif (GRID_NORMAL_SETTINGS & 3) == 1
	vec2 i = sin(M_PI*t);
	vec2 xy = sin(2.0*M_PI*t);

	vec3 normal = vec3(0.0, 0.0, 0.0);
#if GRID_NORMAL_SETTINGS & 8
	vec3 n0 = vec3(-xy.x, 0.0, 0.0);
	vec3 n1 = vec3(0.0, xy.y, 0.0);

	float d = abs(i.x - i.y);
	float sum = i.x + i.y;

	if(i.x > i.y) normal = n0;
	else normal = n1;

	if(d < 0.2) {
		float a = 1.0 - d / 0.2;
		vec3 n2 = 0.5*(n0 + n1);
		normal = mix(normal, n2, a);
	}
	float v = normal.x*normal.x + normal.y*normal.y;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#else
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

	float v = normal.x + normal.y;
	v *= v;
	normal.z = (v >= 0.99999) ? 0.0 : sqrt(1.0 - v);
#endif

#elif (GRID_NORMAL_SETTINGS & 3) == 2
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif

	vec3 normal;
	if(i.x > i.y) normal = vec3(-xy.x, 0.0, z.x);
	else normal = vec3(0.0, xy.y, z.y);

    normal = normalize(normal);
#elif (GRID_NORMAL_SETTINGS & 3) == 3
	vec2 i = sin(M_PI*t);
#if GRID_NORMAL_SETTINGS & 8
	vec2 xy = sin(0.5*M_PI*sin(2.0*M_PI*t));
	vec2 z = 0.5*sin(0.5*M_PI*cos(2.0*M_PI*t)) + 0.5;
#else
	vec2 xy = sin(2.0*M_PI*t);
	vec2 z = 0.5*cos(2.0*M_PI*t) + 0.5;
#endif
	
	vec3 normal = vec3(0.0, 0.0, max(z.x, z.y));
	if(i.x > i.y) normal.x = -xy.x;
	else normal.y = xy.y;

    normal = normalize(normal);
#endif

#if GRID_NORMAL_SETTINGS & 4
	normal.xy = -normal.xy;
#endif

    return normal;
}

float compute_grid_factor(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return 0.0;

	float grid_factor = 0.0;
	grid_factor = grids[0].blend_factor * grid_texture(grids[0].scaling*uv, grids[0].thickness);
	grid_factor = max(grid_factor, grids[1].blend_factor * grid_texture(grids[1].scaling*uv, grids[1].thickness));
	return min(grid_factor, 1.0);
}

vec3 compute_grid_normal(vec2 uv) {
	float l = general_settings.length_scale;
	//if(uv.s <= -l || uv.s >= l)// || uv.t <= -1.0 || uv.t >= 1.0)
	//	return vec3(0.0, 0.0, 1.0);
	
	vec3 normal = vec3(0.0, 0.0, 1.0);
	vec3 normal0 = mix(normal, grid_normal(grids[0].scaling*uv, grids[0].thickness), grids[0].blend_factor);
	vec3 normal1 = mix(normal, grid_normal(grids[1].scaling*uv, grids[1].thickness), grids[1].blend_factor);

	float grid_blend_factor = grid_texture(grids[0].scaling*uv, grids[0].thickness);
	return normalize(mix(normal0, normal1, 1.0 - grid_blend_factor));
}















// remap value v from range [r.x,r.y] to [r.z,r.w]
float remap(float v, vec4 r) {
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return mix(r.z, r.w, t);
}

// clamp value v to range [r.x,r.y] and remap to [r.z,r.w]
float clamp_remap(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return mix(r.z, r.w, t);
}

// clamp value v to range [r.x,r.y] and remap to [0,1]
float clamp_remap01(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return t;
}

// clamp value v to range [r.x,r.y] and remap to [-1,1]
float clamp_remap11(float v, vec4 r) {
	v = clamp(v, r.x, r.y);
	float t = 0.0;
	if(abs(r.x - r.y) > 0.00001)
		t = (v - r.x) / (r.y - r.x);
	return 2.0*t - 1.0;
}

//vec3 map_to_color(float v, float map_idx_coord) {
vec3 map_to_color(float v, int color_map_idx) {
	vec2 ts = textureSize(color_maps_tex, 0);
	float half_step = 0.5 * (1.0 / ts.y);
	float map_coord = float(color_map_idx) / ts.y + half_step;
	return texture(color_maps_tex, vec2(v, map_coord)).rgb;
}

// return a rotation matrix given angle in radians
mat2 rot_mat(float a) {
	float as = sin(a);
	float ac = cos(a);
	return mat2(ac, as, -as, ac);
}

// rotate a 2d point by the given angle in radians
vec2 rotate(in vec2 p, in float a) {
	const float quarter_turn = 1.57079632679; // additional rotation of 90 degrees, so an angle of 0 degrees points the glyph into the direction of the segment
	a += quarter_turn;
	return rot_mat(a) * p;
}

// SDF operations
float op_union(float d0, float d1) {
  return min(d0, d1);
}

float op_subtract(float d0, float d1) {
	return max(-d0, d1);
}

float op_onion(float d, float r) {
  return abs(d) - r;
}

float dot2(in vec2 v) { return dot(v, v); }

// most SDFs from https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm

// dummy that returns a negative distance as if we are always in the interior of tha shape
float sd_color(in vec2 p) {
    return -1.0;
}

// r is the radius of the circle
float sd_circle(in vec2 p, in float r) {
    return length(p) - r;
}

// a is the width/length of the rectangle
// b is the height of the rectangle
float sd_rectangle(in vec2 p, in float a, in float b) {
    vec2 d = abs(p)-0.5*vec2(a,b);
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

// r is the radius of the circle wedge
// a is the aperture angle in radians
float sd_wedge(in vec2 p, in float r, in float a) {
	vec2 sca = vec2(sin(a), cos(a));

    p.x = abs(p.x);
    float l = length(p) - r;
    float m = length(p-sca*clamp(dot(p,sca),0.0,r));
    return max(l,m*sign(sca.y*p.x-sca.x*p.y));
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_flat(in vec2 p, in float ra, in float rb, in float a) {
	float d0 = sd_wedge(p, ra + rb, a);
	float d1 = sd_circle(p, ra - rb);
	return op_subtract(d1, d0);
}

// ra is the radius of the arc
// rb is the radius of the stroke
// a is the aperture angle in radians
float sd_arc_rounded(in vec2 p, in float ra, in float rb, in float a) {
	vec2 sca = vec2(sin(a), cos(a));
    p.x = abs(p.x);
    float k = (sca.y*p.x>sca.x*p.y) ? dot(p,sca) : length(p);
    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;
}

/*
	Currently the triangle is centered and rotates around the tip. To center it to the middle of the height use:
	sd = sd_triangle_isosceles(
		rotate(glyphuv, radians(current_glyph.angle1)) - vec2(0.0, current_glyph.radius1),
		vec2(current_glyph.radius0, -2.0*current_glyph.radius1)
	);
*/
// bw is the base width of the triangle
// h is the height of the triangle
float sd_triangle_isosceles(in vec2 p, in float bw, in float h) {
	// in the default configuration the origin is at the tip of the two equal-length sides

	// flip so default orientation is along trajectory direction
	h = -h;

	// move orign to base side of triangle
	// p += h;
	// or...
	// move origin to center of triangle
	p.y += 0.5*h;

	vec2 q = vec2(0.5*bw, h);
    p.x = abs(p.x);
    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );
    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );
    float s = -sign( q.y );
    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),
                  vec2( dot(b,b), s*(p.y-q.y) ));
    return -sqrt(d.x)*sign(d.y);
}

// r1 is the base radius
// r2 is the tip radius0
// h is the height/length of the capsule
// alternative name: uneven_capsule
float sd_drop(vec2 p, float r1, float r2, float h) {
    p.x = abs(p.x);
    float b = (r1 - r2) / h;
    float a = sqrt(1.0 - b*b);
    float k = dot(p, vec2(-b, a));
    if(k < 0.0)
		return length(p) - r1;
    if(k > a*h)
		return length(p - vec2(0.0, h)) - r2;
    return dot(p, vec2(a, b)) - r1;
}

// intersection of 4 circles with unit radius
float sd_rounded_cross(in vec2 p, in float r) {
    p = abs(p);
    return
		(p.x < r && p.y < r) ? 
		r - sqrt(dot2(p - vec2(r))) :     // circular arc
		sqrt(min(dot2(p - vec2(0.0,r)),   // top corner
                 dot2(p - vec2(r,0.0)))); // right corner
}

// b is the size of the cross (total width/diameter)
// r is distance radius offset
float sd_cross(in vec2 p, in vec2 b, float r) {
    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;
    b *= 0.5;
	vec2  q = p - b;
    float k = max(q.y,q.x);
    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);
    float d = length(max(w,0.0));
    return ((k>0.0)?d:-d) + r;
}

// s is the size of the blob (total width/diameter)
// v defines the shape
// must be in [-1,1]
float sd_sign_blob(in vec2 p, in float s, in float v) {
	// first form
	// -1 is sharp pointy cross
	//  0 is circle
	// +1 is square
	//float d_circle = sd_circle(p, 0.5641896*r);
	//return v < 0.0 ?
	//	mix(sd_rounded_cross(p, 1.079328*r), d_circle, v + 1.0) :
	//	mix(d_circle, sd_rectangle(p, r, r), v);

	// second form
	// -1 is sharp pointy cross
	//  0 is diamond
	// +1 is circle
	//float d_cross = sd_rounded_cross(p, 1.079328*r);
	//float d_circle = sd_circle(p, 0.5641896*r);
	//return mix(d_cross, d_circle, 0.5*v + 0.5);

	// third form
	// -1 is minus sign
	//  0 is circle
	// +1 is plus sign
	float d_circle = sd_circle(p, 0.25*s);
	return v < 0.0 ?
		mix(sd_rectangle(p, s, 0.2*s), d_circle, v + 1.0) :
		mix(d_circle, sd_cross(p, vec2(s, 0.2*s), 0.0), v);
}

float sd_segment(in vec2 p, in vec2 a, in vec2 b) {
    vec2 pa = p-a, ba = b-a;
    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );
    return length( pa - ba*h );
}

/*#define DEF_SD_POLYGON(I, N) \
float sd_polygon##I(in vec2 p, in vec2[N] v) { \
    float d = dot(p-v[0],p-v[0]); \
    float s = 1.0; \
    for(int i = 0, j = N - 1; i < N; j = i, ++i) { \
        vec2 e = v[j] - v[i]; \
        vec2 w =    p - v[i]; \
        vec2 b = w - e * clamp(dot(w, e) / dot(e, e), 0.0, 1.0); \
        d = min(d, dot(b, b)); \
        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x); \
        if(all(c) || all(not(c))) s *= -1.0; \
    } \
    return s * sqrt(d); \
}*/

/*#define DEF_SD_STAR(I, N) \
vec2 sd_star##I(vec2 p, float r, in glyph_desc##I gd, in int mapping_base_idx) { \
	vec2 org = vec2(0.0); \
	float d_axes = 1e20; \
	float d_poly = 1e20; \
	float thickness = 0.01; \
	vec2 ps[N]; \
	\
	for(int i = 0; i < N; ++i) { \
		float v = clamp_remap(gd.v[i], glyph_m_param[mapping_base_idx + i]); \
		float angle = 2.0*M_PI * (i / float(N)) + M_PI; \
		mat2 R = rot_mat(angle); \
		vec2 end = R * vec2(0.0, 1.0); \
		vec2 pp = R * vec2(0.0, v); \
		ps[i] = r*pp; \
		d_axes = op_union(d_axes, sd_segment(p, org, (r - 2.0*thickness) * pp) - thickness); \
	} \
	d_poly = sd_polygon##I(p, ps); \
	return vec2(d_axes, d_poly); \
}

#define DEF_SPLAT_STAR(I, N) \
vec4 splat_star##I(in glyph_desc##I gd, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	vec2 dist = sd_star##I(p, glyph_cf_param[float_base_idx], gd, mapping_base_idx); \
	float alpha_fac = 1.0; \
	\
	if(gd.debug_info > 0) \
		alpha_fac = 0.5; \
	\
	vec3 dist3 = vec3(dist, op_onion(dist.y + 0.01, 0.01)); \
	\
	const vec3 antialias_width = general_settings.antialias_radius*fwidth(dist3); \
	vec3 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist3); \
	\
	float theta = atan(-p.x, p.y) + M_PI; \
	theta /=  2.0*M_PI; \
	float omega = N * theta; \
	int ci0 = int(omega)%N; \
	omega = fract(omega); \
	int ci1 = (ci0 + 1)%N; \
	\
	float limit = mix(0.01, 0.5, glyph_cf_param[float_base_idx + 2]); \
	float t = smoothstep(0.5 - limit, 0.5 + limit, omega); \
	vec3 col = mix(glyph_cc_param[color_base_idx + ci0 + 1], glyph_cc_param[color_base_idx + ci1 + 1], t); \
	\
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		col = mix(col, glyph_cc_param[color_base_idx], alpha.x); \
	} else { \
		col = mix(glyph_cc_param[color_base_idx], col, alpha.x); \
	} \
	return vec4(col, alpha_fac * max(alpha.x, max((1.0 - glyph_cf_param[float_base_idx + 3])*alpha.y, alpha.z))); \
}*/







float sd_triangle(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {
    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;
    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;
    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    float s = sign( e0.x*e2.y - e0.y*e2.x );
    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),
                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),
                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));
    return -sqrt(d.x)*sign(d.y);
}

#define DEF_SD_STAR(I, N) \
vec3 sd_star##I(vec2 p, in glyph_desc##I gd, in int i0, in int i1, in int float_base_idx, in int mapping_base_idx) { \
	const vec2 org = vec2(0.0); \
	const float thickness = 0.01; \
	float d_axes = 1e20; \
	\
	vec2 ps0, ps1; \
	vec2 ps[N]; \
	\
	float r = glyph_cf_param[float_base_idx]; \
	float mt = step(0.5, glyph_cf_param[float_base_idx + 4]); \
	\
	float angle_step = 2.0*M_PI * (1.0 / float(N)); \
	vec4 mapping = glyph_m_param[mapping_base_idx + i0]; \
	float v = clamp_remap(gd.v[i0], mapping); \
	mat2 R = rot_mat(i0 * angle_step + M_PI); \
	vec2 pp = R * vec2(0.0, 1.0); \
	ps0 = max(r*v, 0.001)*pp; \
	d_axes = sd_segment(p, org, r*mix(mapping.w, v, mt)*pp) - thickness; \
	\
	mapping = glyph_m_param[mapping_base_idx + i1]; \
	v = clamp_remap(gd.v[i1], mapping); \
	R = rot_mat(i1 * angle_step + M_PI); \
	pp = R * vec2(0.0, 1.0); \
	ps1 = max(r*v, 0.001)*pp; \
	d_axes = op_union(d_axes, sd_segment(p, org, r*mix(mapping.w, v, mt)*pp) - thickness); \
	\
	float d_fill = sd_triangle(p, org, ps0, ps1); \
	float d_contour = sd_segment(p, ps0, ps1) - thickness; \
	\
	return vec3(d_axes, d_fill, d_contour); \
}

#define DEF_SPLAT_STAR(I, N) \
vec4 splat_star##I(in glyph_desc##I gd, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	float theta = atan(-p.x, p.y) + M_PI; \
	theta /=  2.0*M_PI; \
	float omega = N * theta; \
	int ci0 = int(omega)%N; \
	omega = fract(omega); \
	int ci1 = (ci0 + 1)%N; \
	\
	vec3 dist3 = sd_star##I(p, gd, ci0, ci1, float_base_idx, mapping_base_idx); \
	float alpha_fac = 1.0; \
	\
	if(gd.debug_info > 0) \
		alpha_fac = 0.5; \
	\
	\
	const vec3 antialias_width = general_settings.antialias_radius*fwidth(dist3); \
	vec3 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist3); \
	\
	\
	float limit = mix(0.01, 0.5, glyph_cf_param[float_base_idx + 2]); \
	float t = smoothstep(0.5 - limit, 0.5 + limit, omega); \
	vec3 col = mix(glyph_cc_param[color_base_idx + ci0 + 1], glyph_cc_param[color_base_idx + ci1 + 1], t); \
	\
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		col = mix(col, glyph_cc_param[color_base_idx], alpha.x); \
	} else { \
		col = mix(glyph_cc_param[color_base_idx], col, alpha.x); \
	} \
	return vec4(col, alpha_fac * max(alpha.x, max((1.0 - glyph_cf_param[float_base_idx + 3])*alpha.y, alpha.z))); \
}





#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
//DEF_SD_POLYGON(0, L0_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(0, L0_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(0, L0_MAPPED_ATTRIB_COUNT);
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
//DEF_SD_POLYGON(1, L1_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(1, L1_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(1, L1_MAPPED_ATTRIB_COUNT);
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
//DEF_SD_POLYGON(2, L2_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(2, L2_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(2, L2_MAPPED_ATTRIB_COUNT);
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
//DEF_SD_POLYGON(3, L3_MAPPED_ATTRIB_COUNT);
DEF_SD_STAR(3, L3_MAPPED_ATTRIB_COUNT);
DEF_SPLAT_STAR(3, L3_MAPPED_ATTRIB_COUNT);
#endif

/*#define DEF_SPLAT_COLOR(I) \
vec4 splat_color##I(in glyph_desc##I gd, in glyph_desc##I gd_prev, in glyph_desc##I gd_next, in vec2 p, in int color_map_idx, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	vec4 mapping_range = glyph_m_param[mapping_base_idx]; \
	float v0 = clamp_remap01(gd.v[0], mapping_range); \
	float v1; \
	float t; \
	if(p.x < gd.s) { \
		t = 1.0 - clamp_remap01(p.x, vec4(gd_prev.s, gd.s, 0.0, 0.0)); \
		v1 = clamp_remap01(gd_prev.v[0], mapping_range); \
	} else { \
		t = clamp_remap01(p.x, vec4(gd.s, gd_next.s, 0.0, 0.0)); \
		v1 = clamp_remap01(gd_next.v[0], mapping_range); \
	} \
	t = glyph_cf_param[float_base_idx] < 0.5 ? step(0.5, t) : t; \
	vec3 color; \
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		vec3 c0 = map_to_color(v0, color_map_idx); \
		vec3 c1 = map_to_color(v1, color_map_idx); \
		color = mix(c0, c1, t); \
	} else { \
		v0 = mix(v0, v1, t); \
		color = color_map_idx < 0 ? vec3(0.0) : map_to_color(v0, color_map_idx); \
	} \
	return vec4(color, 1.0); \
}*/

/*#define DEF_SPLAT_COLOR(I) \
vec4 splat_color##I(in int gid, in vec2 p, in int color_map_idx, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	float itype = glyph_cf_param[float_base_idx]; \
	float s = glyphs##I[gid].s; \
	float v0 = clamp_remap01(glyphs##I[gid].v[0], glyph_m_param[mapping_base_idx]); \
	float v1; \
	float t; \
	if(p.x < s) { \
		t = 1.0 - clamp_remap01(p.x, vec4(glyphs##I[gid-1].s, s, 0.0, 0.0)); \
		v1 = clamp_remap01(glyphs##I[gid-1].v[0], glyph_m_param[mapping_base_idx]); \
	} else { \
		t = clamp_remap01(p.x, vec4(s, glyphs##I[gid+1].s, 0.0, 0.0)); \
		v1 = clamp_remap01(glyphs##I[gid+1].v[0], glyph_m_param[mapping_base_idx]); \
	} \
	t = itype < 0.5 ? step(0.5, t) : t; \
	vec3 color; \
	if(glyph_cf_param[float_base_idx + 1] < 0.5) { \
		vec3 c0 = map_to_color(v0, color_map_idx); \
		vec3 c1 = map_to_color(v1, color_map_idx); \
		color = mix(c0, c1, t); \
	} else { \
		v0 = mix(v0, v1, t); \
		color = map_to_color(v0, color_map_idx); \
	} \
	return vec4(color, 1.0); \
}*/

float eval_cubic_hermite(float t, in vec4 Bk)
{
	mat4 Mh; // hermite matrix
	Mh[0] = vec4( 2, -3,  0,  1);
	Mh[1] = vec4(-2,  3,  0,  0);
	Mh[2] = vec4( 1, -2,  1,  0);
	Mh[3] = vec4( 1, -1,  0,  0);

	vec4 T = vec4(t*t*t, t*t, t, 1.0);
	return dot(T, Mh * Bk); // equivalent to T^T * Mh * Bk
}

#define DEF_SPLAT_COLOR(I) \
vec4 splat_color##I(in int gid, in vec2 p, in int color_map_idx, in int float_base_idx, in int color_base_idx, in int mapping_base_idx) { \
	float itype = glyph_cf_param[float_base_idx]; \
	int i0, i1;\
	if(p.x < glyphs##I[gid].s) { \
		i0 = gid - 1; \
		i1 = gid; \
	} else { \
		i0 = gid; \
		i1 = gid + 1; \
	} \
	\
	vec4 s, v; \
	s.x = glyphs##I[i0-1].s; \
	s.y = glyphs##I[i0+0].s; \
	s.z = glyphs##I[i1+0].s; \
	s.w = glyphs##I[i1+1].s; \
	\
	vec4 range = glyph_m_param[mapping_base_idx]; \
	v.x = clamp_remap01(glyphs##I[i0-1].v[0], range); \
	v.y = clamp_remap01(glyphs##I[i0+0].v[0], range); \
	v.z = clamp_remap01(glyphs##I[i1+0].v[0], range); \
	v.w = clamp_remap01(glyphs##I[i1+1].v[0], range); \
	\
	float m0 = 0.5 * (v.z - v.x); \
	float m1 = 0.5 * (v.w - v.y); \
	\
	float t = clamp_remap01(p.x, vec4(s.y, s.z, 0.0, 0.0)); \
	\
	float val; \
	if(itype < 0.333) { \
		val = mix(v.y, v.z, step(0.5, t)); \
	} else if(itype < 0.666) { \
		val = mix(v.y, v.z, t); \
	} else { \
		vec4 Bk = vec4(v.y, v.z, m0, m1); \
		val = eval_cubic_hermite(t, Bk); \
		val = clamp(val, 0.0, 1.0); \
	} \
	return vec4(color_map_idx > -1 ? map_to_color(val, color_map_idx) : vec3(0.0), 1.0); \
}
	//return vec4(val < 0.0 ? vec3(-val, 0.0,  0.0) : vec3(0.0, val, 0.0), 1.0); \

//

/*
float s = glyphs##I[gid].s; \
	float vp1 = glyphs##I[gid-2].v[0]; \
	float vp0 = glyphs##I[gid-1].v[0]; \
	float v0 =  glyphs##I[gid].v[0]; \
	float vn0 = glyphs##I[gid+1].v[0]; \
	float vn1 = glyphs##I[gid+2].v[0]; \
	\
	float tp = v0 - vp1; \
	float t0 = vn0 - vp0; \
	float tn = vn1 - v0; \
	\
	float v1, t1; \
	float t; \
	if(p.x < s) { \
		t = clamp_remap01(p.x, vec4(glyphs##I[gid-1].s, s, 0.0, 0.0)); \
		v1 = v0; \
		v0 = vp0; \
		t1 = t0; \
		t0 = tp; \
	} else { \
		t = clamp_remap01(p.x, vec4(s, glyphs##I[gid+1].s, 0.0, 0.0)); \
		v1 = vn0; \
		t1 = tn; \
	} \
	t = itype < 0.5 ? step(0.5, t) : t; \
	vec3 color; \
	float pp = glyph_cf_param[float_base_idx + 1]; \
	t0 *= 0.5; \
	t1 *= 0.5; \
	vec4 Bk = vec4(v0, v1, t0, t1); \
	float v; \
	if(pp < 0.5) v = eval_cubic_hermite(Bk, t); \
	else v = mix(v0, v1, t); \
	v = clamp_remap01(v, glyph_m_param[mapping_base_idx]); \
	color = map_to_color(v, color_map_idx); \
	return vec4(color, 1.0); \
*/

	//return vec4(v < 0.0 ? vec3(-v, 0.0, 0.0) : vec3(0.0, v, 0.0), 1.0); \

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(0)
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(1)
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(2)
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_FLOAT_UNIFORM_COUNT > 0
DEF_SPLAT_COLOR(3)
#endif

/*#define DEF_SPLAT_LINE_PLOT(I, N) \
vec4 splat_line_plot##I(in int gid, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx, in float outline) { \
	int idx = int(float(N) * (0.5*p.y + 0.5)); \
	idx = min(idx, N - 1); \
	\
	float st = 2.0/float(N); \
	float offset = -1.0 + st*float(idx) + 0.5*st; \
	p.y += -offset; \
	p.y *= float(N); \
	p.y = abs(p.y); \
	\
	vec4 mapping_ranges = glyph_m_param[mapping_base_idx + idx]; \
	float s0; \
	float s1 = glyphs##I[gid].s; \
	float v0; \
	float v1 = clamp_remap(glyphs##I[gid].v[idx], mapping_ranges); \
	float t; \
	if(p.x < s1) { \
		s0 = glyphs##I[gid - 1].s; \
		v0 = clamp_remap(glyphs##I[gid - 1].v[idx], mapping_ranges); \
		t = clamp_remap01(p.x, vec4(s0, s1, 0.0, 0.0)); \
	} else { \
		s0 = glyphs##I[gid + 1].s; \
		v0 = clamp_remap(glyphs##I[gid + 1].v[idx], mapping_ranges); \
		t = 1.0 - clamp_remap01(p.x, vec4(s1, s0, 0.0, 0.0)); \
	} \
	float v = mix(v0, v1, t); \
	float dist = p.y - v; \
	vec2 dist2 = vec2(dist, dist - outline); \
	const vec2 antialias_width = general_settings.antialias_radius*fwidth(dist2); \
	vec2 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist2); \
	vec3 glyph_color = glyph_cc_param[color_base_idx + idx]; \
	if(outline < 0.01) { \
		return vec4(glyph_color, alpha.x); \
	} else { \
		vec4 color = vec4(vec3(0.0), alpha.y); \
		return mix(color, vec4(glyph_color, 1.0), alpha.x); \
	} \
}*/


#define DEF_SPLAT_LINE_PLOT(I, N) \
vec4 splat_line_plot##I(in int gid, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx, in float outline) { \
	int idx = int(float(N) * (0.5*p.y + 0.5)); \
	idx = min(idx, N - 1); \
	\
	float st = 2.0/float(N); \
	float offset = -1.0 + st*float(idx) + 0.5*st; \
	p.y += -offset; \
	p.y *= float(N); \
	p.y = abs(p.y); \
	\
	float itype = glyph_cf_param[float_base_idx + 1]; \
	int i0, i1;\
	if(p.x < glyphs##I[gid].s) { \
		i0 = gid - 1; \
		i1 = gid; \
	} else { \
		i0 = gid; \
		i1 = gid + 1; \
	} \
	\
	vec4 s, v; \
	s.x = glyphs##I[i0-1].s; \
	s.y = glyphs##I[i0+0].s; \
	s.z = glyphs##I[i1+0].s; \
	s.w = glyphs##I[i1+1].s; \
	\
	vec4 range = glyph_m_param[mapping_base_idx + idx]; \
	v.x = clamp_remap(glyphs##I[i0-1].v[idx], range); \
	v.y = clamp_remap(glyphs##I[i0+0].v[idx], range); \
	v.z = clamp_remap(glyphs##I[i1+0].v[idx], range); \
	v.w = clamp_remap(glyphs##I[i1+1].v[idx], range); \
	\
	float m0 = 0.5 * (v.z - v.x); \
	float m1 = 0.5 * (v.w - v.y); \
	\
	float t = clamp_remap01(p.x, vec4(s.y, s.z, 0.0, 0.0)); \
	\
	float val; \
	if(itype < 0.333) { \
		val = mix(v.y, v.z, step(0.5, t)); \
	} else if(itype < 0.666) { \
		val = mix(v.y, v.z, t); \
	} else { \
		vec4 Bk = vec4(v.y, v.z, m0, m1); \
		val = eval_cubic_hermite(t, Bk); \
		val = clamp(val, 0.0, 1.0); \
	} \
	\
	float dist = p.y - val; \
	vec2 dist2 = vec2(dist, dist - outline); \
	const vec2 antialias_width = general_settings.antialias_radius*fwidth(dist2); \
	vec2 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist2); \
	vec3 glyph_color = glyph_cc_param[color_base_idx + idx]; \
	\
	if(outline < 0.01) { \
		return vec4(glyph_color, alpha.x); \
	} else { \
		vec4 color = vec4(vec3(0.0), alpha.y); \
		return mix(color, vec4(glyph_color, 1.0), alpha.x); \
	} \
}

// other form of line plot shows absolute value in width and shows negative values with checker board texture
// change clamp_remap on v to clamp_remap11
// change val = clamp(val, 0.0, 1.0); to val = clamp(val, -1.0, 1.0);
// add after interpolation step:
//bool neg = val < 0.0; \
//val = mix(range.z, range.w, abs(val)); \
// add after glyph_color:
//float gv = neg ? checker_texture_aa(vec2(general_settings.length_scale*4.0, 4.0)*p, 0.5, 1.0) : 1.0;\
// change return vec4(glyph_color, alpha.x); to return vec4(glyph_color, gv * alpha.x);
// change return mix(color, vec4(glyph_color, 1.0), alpha.x); to return mix(color, vec4(glyph_color, gv), alpha.x);

/*#define DEF_SPLAT_LINE_PLOT(I, N) \
vec4 splat_line_plot##I(in glyph_desc##I gd, in glyph_desc##I gd_prev, in glyph_desc##I gd_next, in vec2 p, in int float_base_idx, in int color_base_idx, in int mapping_base_idx, in float outline) { \
	int idx = int(float(N) * (0.5*p.y + 0.5)); \
	idx = min(idx, N - 1); \
	\
	float st = 2.0/float(N); \
	float offset = -1.0 + st*float(idx) + 0.5*st; \
	p.y += -offset; \
	p.y *= float(N); \
	p.y = abs(p.y); \
	\
	vec4 mapping_ranges = glyph_m_param[mapping_base_idx + idx]; \
	float s0; \
	float s1 = gd.s; \
	float v0; \
	float v1 = clamp_remap(gd.v[idx], mapping_ranges); \
	float t; \
	if(p.x < gd.s) { \
		s0 = gd_prev.s; \
		v0 = clamp_remap(gd_prev.v[idx], mapping_ranges); \
		t = clamp_remap01(p.x, vec4(gd_prev.s, gd.s, 0.0, 0.0)); \
	} else { \
		s0 = gd_next.s; \
		v0 = clamp_remap(gd_next.v[idx], mapping_ranges); \
		t = 1.0 - clamp_remap01(p.x, vec4(gd.s, gd_next.s, 0.0, 0.0)); \
	} \
	float v = mix(v0, v1, t); \
	float dist = p.y - v; \
	vec2 dist2 = vec2(dist, dist - outline); \
	const vec2 antialias_width = general_settings.antialias_radius*fwidth(dist2); \
	vec2 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist2); \
	vec3 glyph_color = glyph_cc_param[color_base_idx + idx]; \
	if(outline < 0.01) { \
		return vec4(glyph_color, alpha.x); \
	} else { \
		vec4 color = vec4(vec3(0.0), alpha.y); \
		return mix(color, vec4(glyph_color, 1.0), alpha.x); \
	} \
}*/

/*
float dist = p.y - vv; \
	\
	const float antialias_width = general_settings.antialias_radius*fwidth(dist); \
	float alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist); \
	\
	return vec4(glyph_cc_param[color_base_idx + idx], alpha); \
*/

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_LINE_PLOT(0, L0_MAPPED_ATTRIB_COUNT);
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_LINE_PLOT(1, L1_MAPPED_ATTRIB_COUNT);
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_LINE_PLOT(2, L2_MAPPED_ATTRIB_COUNT);
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_LINE_PLOT(3, L3_MAPPED_ATTRIB_COUNT);
#endif











#define DEF_SPLAT_TEMPORAL_HEAT_MAP(I, N) \
vec4 splat_temporal_heat_map##I(in int gid, in vec2 p, in int color_map_idx, in int float_base_idx, in int color_base_idx, in int mapping_base_idx, in float outline) { \
	int idx = int(float(N) * (0.5*p.y + 0.5)); \
	idx = min(idx, N - 1); \
	\
	float st = 2.0/float(N); \
	float offset = -1.0 + st*float(idx) + 0.5*st; \
	p.y += -offset; \
	p.y *= float(N); \
	p.y = abs(p.y); \
	\
	float itype = glyph_cf_param[float_base_idx + 1]; \
	int i0, i1;\
	if(p.x < glyphs##I[gid].s) { \
		i0 = gid - 1; \
		i1 = gid; \
	} else { \
		i0 = gid; \
		i1 = gid + 1; \
	} \
	\
	vec4 s, v; \
	s.x = glyphs##I[i0-1].s; \
	s.y = glyphs##I[i0+0].s; \
	s.z = glyphs##I[i1+0].s; \
	s.w = glyphs##I[i1+1].s; \
	\
	vec4 range = glyph_m_param[mapping_base_idx + idx]; \
	v.x = clamp_remap(glyphs##I[i0-1].v[idx], range); \
	v.y = clamp_remap(glyphs##I[i0+0].v[idx], range); \
	v.z = clamp_remap(glyphs##I[i1+0].v[idx], range); \
	v.w = clamp_remap(glyphs##I[i1+1].v[idx], range); \
	\
	float m0 = 0.5 * (v.z - v.x); \
	float m1 = 0.5 * (v.w - v.y); \
	\
	float t = clamp_remap01(p.x, vec4(s.y, s.z, 0.0, 0.0)); \
	\
	float val; \
	if(itype < 0.333) { \
		val = mix(v.y, v.z, step(0.5, t)); \
	} else if(itype < 0.666) { \
		val = mix(v.y, v.z, t); \
	} else { \
		vec4 Bk = vec4(v.y, v.z, m0, m1); \
		val = eval_cubic_hermite(t, Bk); \
		val = clamp(val, 0.0, 1.0); \
	} \
	\
	float dist = p.y - 1.0 + outline; \
	const float antialias_width = general_settings.antialias_radius*fwidth(dist); \
	float alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist); \
	vec3 glyph_color = color_map_idx > -1 ? map_to_color(val, color_map_idx) : vec3(0.0); \
	if(outline >= 0.01) \
		glyph_color = mix(vec3(0.0), vec3(glyph_color), alpha); \
	return vec4(glyph_color, 1.0); \
}

//vec2 dist2 = vec2(dist, dist - outline); \

#if L0_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_TEMPORAL_HEAT_MAP(0, L0_MAPPED_ATTRIB_COUNT);
#endif

#if L1_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_TEMPORAL_HEAT_MAP(1, L1_MAPPED_ATTRIB_COUNT);
#endif

#if L2_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_TEMPORAL_HEAT_MAP(2, L2_MAPPED_ATTRIB_COUNT);
#endif

#if L3_MAPPED_ATTRIB_COUNT > 0 && CONSTANT_COLOR_UNIFORM_COUNT > 0
DEF_SPLAT_TEMPORAL_HEAT_MAP(3, L3_MAPPED_ATTRIB_COUNT);
#endif









// code for drawing digits from https://www.shadertoy.com/view/lsXXzN
// adjusted to own needs
float segment(vec2 uv, bool on) {
	return on ? (1.0 - smoothstep(0.08, 0.09 + float(on)*0.02, abs(uv.x))) *
			    (1.0 - smoothstep(0.46, 0.47 + float(on)*0.02, abs(uv.y) + abs(uv.x)))
		        : 0.0;
}

float digit(vec2 uv, uint num) {
	float seg = 0.0;
    seg += segment(uv.yx + vec2(-1.0, +0.0), num!=1 && num!=4                    );
	seg += segment(uv.xy + vec2(-0.5, -0.5), num!=1 && num!=2 && num!=3 && num!=7);
	seg += segment(uv.xy + vec2(+0.5, -0.5), num!=5 && num!=6                    );
   	seg += segment(uv.yx + vec2(+0.0, +0.0), num!=0 && num!=1 && num!=7          );
	seg += segment(uv.xy + vec2(-0.5, +0.5), num==0 || num==2 || num==6 || num==8);
	seg += segment(uv.xy + vec2(+0.5, +0.5), num!=2                              );
    seg += segment(uv.yx + vec2(+1.0, +0.0), num!=1 && num!=4 && num!=7          );	
	return seg;
}

/* To show hidden glyphs only as a ring:
	if(debug_info > 0) {
		alpha_fac = 0.5; // make glyph half transparent
		dist = op_onion(dist + 0.05, 0.05); // draw outline of glyph (keeps original size)
	}
*/

vec4 splat_generic_glyph(in uint debug_info, in float dist, in vec3 glyph_color, in float outline) {
	
	// debug only
	// show otherwise not drawn glyphs
	float alpha_fac = 1.0;
	if(debug_info > 0)
		alpha_fac = 0.5; // make glyph half transparent

	// >> non-debuig implementation
	// pre-filter the SDF for AA
#if OUTLINE_INWARDS == 0
	vec2 dist2 = vec2(dist, dist - outline);
	#else
	vec2 dist2 = vec2(dist + outline, dist);
#endif
	const vec2 antialias_width = general_settings.antialias_radius*fwidth(dist2);
	vec2 alpha = 1.0 - smoothstep(-antialias_width, antialias_width, dist2);
	alpha *= alpha_fac;
	if(outline < 0.01) {
		return vec4(glyph_color, alpha.x);
	} else {
		vec4 color = vec4(vec3(0.0), alpha.y);
		return mix(color, vec4(glyph_color, 1.0), alpha.x);
	}

	//return mix(glyph_color, color, smoothstep(-antialias_width, antialias_width, dist));
	// <<
}

void finalize_glyph(in uint debug_info, in vec2 uv, in vec4 glyph_color, inout vec3 color) {

	// >> non-debug implementation
	color = mix(color, glyph_color.rgb, glyph_color.a);
	// <<

	// number overlay (debug only)
	// draw a digit showing the number of interpolated attributes for the current glyph
	//vec2 digit_uv = -6.0 * uv;
	//color = mix(color, 1.0-color, digit(digit_uv, interpolated_attrib_count));

	/*color = mix(color, 1.0-color, digit(digit_uv, interpolated_attrib_count));
	digit_uv = 2.0 * digit_uv;*/

	/*float value = gd.radius;

	float decimal_dot = sd_circle(digit_uv + vec2(0.0, 1.0), 0.15) < 0.0 ? 1.0 : 0.0;

	float digit0 = digit(digit_uv - vec2(1.0, 0.0), uint(value));
	value -= float(uint(value));
	value *= 10.0;
	float digit1 = digit(digit_uv + vec2(1.0, 0.0), uint(value));
	value -= float(uint(value));
	value *= 10.0;
	float digit2 = digit(digit_uv + vec2(3.0, 0.0), uint(round(value)));

	vec3 icol = 1.0 - color;

	color = mix(color, icol, digit0);
	color = mix(color, icol, digit1);
	color = mix(color, icol, digit2);
	color = mix(color, icol, decimal_dot);*/
}




















vec3 apply_visual_mappings(in vec3 color, in vec2 uv, in int segment_id) {

	// glyph layer 0
#if L0_VISIBLE > 0 && L0_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples0(segment_id, glyphuv.s, closest)) {
				glyph_desc0 glyph = glyphs0[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L0_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 1
#if L1_VISIBLE > 0 && L1_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples1(segment_id, glyphuv.s, closest)) {
				glyph_desc1 glyph = glyphs1[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L1_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 2
#if L2_VISIBLE > 0 && L2_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples2(segment_id, glyphuv.s, closest)) {
				glyph_desc2 glyph = glyphs2[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L2_GLYPH_DEFINITION
			}
		}
#endif
		// glyph layer 3
#if L3_VISIBLE > 0 && L3_MAPPED_ATTRIB_COUNT > 0
		{
			closest_glyphs_info closest;
			vec2 glyphuv = uv;
			if (get_closest_samples3(segment_id, glyphuv.s, closest)) {
				glyph_desc3 glyph = glyphs3[closest.id];

				glyphuv = vec2(
					(closest.dp <= closest.dn ? closest.dp : -closest.dn)
					* general_settings.length_scale, // <-- ToDo: replace with automatic uv re-projection method
					glyphuv.t
				);

				L3_GLYPH_DEFINITION
			}
		}
#endif

	return color;
}






























// use a custom finish fragment method since the framework built-in one imposes a performance loss
void finish_fragment(vec4 color) {
	frag_color = vec4(clamp(pow(color.rgb, vec3(2.2)), 0.0, 0.999999), color.a);
}

void main()
{
#if MODE == 0
	discard;
	return;
#elif MODE == 1
	finish_fragment(vec4(1.0, 0.0, 0.0, 1.0));
	return;
#else

#if USE_VIEW_SPACE_POSITION == 0
	// transform fragment coordinates from window coordinates to clip coordinates
    vec4 coord = gl_FragCoord 
        * vec4(2.0 / viewport.z, 2.0 / viewport.w, 2.0, 0.0) 
        + vec4(-1.0, -1.0, -1.0, 1.0);

    // transform fragment coordinates from clip coordinates to eye coordinates
    coord = get_inverse_projection_matrix() * coord;
    coord /= coord.w;

    // calculate the viewing ray
    vec3 direction = normalize(coord.xyz);
#else
	vec3 direction = normalize(position_fs);
#endif

	Hit hit = EvalSplineISect(direction,
		qTube_fs.s.pos, qTube_fs.h.pos, qTube_fs.e.pos,
		qTube_fs.s.rad, qTube_fs.h.rad, qTube_fs.e.rad
	);

#if MODE == 3
	gl_FragDepth = 1.0;
#endif

	if(hit.t == POS_INF || (hit.cap && hit.t > cap_clip_distance)) {
#if MODE == 2
		finish_fragment(vec4(1.0, 0.0, 0.0, 1.0));
#else
		discard;
#endif
	}

	vec3 hit_pos_eye = direction * hit.t;
	float spline_t = hit.l * 0.5 + l_offset_fs;
	// with zero tangents the cubic hermite interpolation is reduced to a linear problem
	vec3 base_color = mix(unpackUnorm4x8(color0_fs).rgb, unpackUnorm4x8(color1_fs).rgb, spline_t);

	vec4 v_eye = vec4(hit_pos_eye, 1.0);
	vec4 depth = get_projection_matrix() * v_eye;
	gl_FragDepth = 0.5*(depth.z / depth.w) + 0.5;

#if USE_CUBIC_TANGENTS == 0
	// tangent is already given in eye space
	vec3 tangent = normalize(eval_quadratic_bezier_tangent(hit.l));
#else
	// tangent is given in object space
	vec3 tangent = eval_cubic_hermite_tangent(spline_t);
	// transform the tangent from object space to eye space
	tangent = normalize(get_normal_matrix() * tangent);
#endif
	// calculate a bitangent which is orthogonal to the plane defined by the tangent and the vector from the eye position to the hit position
	vec3 b = normalize(cross(tangent, hit.sp));
	// the texture coordinate around the tubes perimeter is the acos of the dot product between the normal and the bitangent
	// normalized to [0,1]
	// since we are only interested in the eye-facing side of the tube, acos is sufficient here
	float v = acos(dot(b, hit.normal)) * M_INV_PI;

	vec2 uv = vec2(alen(spline_t), v);

	// The texture coordinate v (around the tube) lies in [0,1] at the front side (camera facing side) of the tube,
	// with 0 at the top and 1 at the bottom of the visible part of the tube (if the bitangent is pointing up in screen space).
	// The back side of the tube is parameterized in the same way, but we are only interested in the front side anyway.
		
	// Move the origin (0,0) to the center of the front side and scale the v coordinate to [-1,1]
	uv.t = 2.0 * uv.t - 1.0;

	// Correct the perspective distortion caused by the curved tube surface by rescaling the v coordinate around the tube.
	if(general_settings.use_curvature_correction)
		uv.t = sin(0.5*M_PI*uv.t);

	// apply the visual mappings to the tube base color
	vec4 final_color = vec4(apply_visual_mappings(base_color, uv, segment_id_fs), 1.0);

	// highlight segments in debug mode if requested
#if DEBUG_SEGMENTS > 0
	if((segment_id&1) > 0) color *= 0.5;
#endif

	// apply grid
#if GRID_MODE & 1
	final_color.rgb = mix(color.rgb, grid_color.rgb, compute_grid_factor(uv) * grid_color.a);
#endif

#if ENABLE_FRAMEWORK_LIGHTING == 1
	// using the framework built-in lighting system costs about 2 ms for the fisch-wehr data set (impact reduces for larger data sets, possibly due to less overdraw)
	final_color = compute_reflected_appearance(hit_pos_eye, hit.normal, final_color, 1);
#else
	// basic diffuse lighting with light position at eye
	float diffuse = max(dot(-normalize(hit_pos_eye), hit.normal), 0.0);
	final_color.rgb *= 0.25 + 0.75*diffuse; // 25% ambient light
#endif

#if GRID_MODE & 2
	//vec3 gn = compute_grid_normal(uv);
	//vec3 bitangent_eye = cross(normal_eye, tangent_eye);
	//mat3 TBN = mat3(tangent_eye, bitangent_eye, normal_eye);
	//vec3 normal_eye_bump = mix(normal_eye, normalize(TBN * gn), normal_mapping_scale);
	//vec4 frag_color_bump = compute_reflected_appearance(pos_eye, normal_eye_bump, vec4(color, 1.0), 1);
	//float aa_factor = min(aa_texture(grids[0].scaling*uv, grids[0].thickness, 0.5) + aa_texture(grids[1].scaling*uv, grids[1].thickness, 0.5), 1);
	//frag_color = mix(frag_color, frag_color_bump, aa_factor);
#endif

	//apply ambient occlusion
	// change if to a define for maximum performance when ambient occlusion is disabled
#if ENABLE_AMBIENT_OCCLUSION == 1
	final_color.rgb *= compute_ambient_occlusion_factor(hit_pos_eye, hit.normal);
#endif


	/*	!!!
	*	enabling either compute_reflected_appearance or compute_ambient_occlusion_factor seems to disable the conservative depth test
	*	!!!
	*/

		
	finish_fragment(final_color);
#endif
}
